### [作品情報]
### 掲載URL=https://n3s.nadesi.com/id.php?576
### タイトル=ThreeJS利用プラグイン(JSプラグイン)
### 作者=てぃふと@うぇいく(user_id=2)
### ライセンス=MIT
### 説明=Javascriptの有名な3DライブラリであるThreeJSをなでしこv3から利用する為のプラグイン。必要になったつど命令を追加しているので、命令数はあまり多くない。
### 対象バージョン=3.2.15
### URL=
### 種類=js
### タグ=
### 更新日時=2022-03-30 22:01:26
###

/**
 * PluginWeykThree
 */
let THREE = null

const PluginWeykThree = {
  '初期化': {
    type: 'func',
    josi: [],
    pure: true,
    fn: function(sys) {
      if (sys._weykthreejs) return
      sys._weykthreejs = {
        _scene : null,
        _camera: null,
        _renderer: null,
        _scene_list : [],
        propMap: {
          "シャドー": "shadow",
          "シャドーマップ": "shadowMap",
          "カメラ": "camera"
        },
        clearAll: function() {
          const me = this
          console.log('[THREEJS] clearAll')
          // シーンに存在する要素を全部削除して解放
          const scenes = me._scene_list
          scenes.forEach((scene) => {
            if (scene !== null) {
              disposeChildObject(scene)
            }
          })
          me._scene = null
          me._camera = null
          me._scene_list = []
        },
        setupRenderer: function (to) {
          const me = this
          if (to instanceof THREE.WebGLRenderer) {
            me._renderer = renderer
            return renderer
          }
          let renderer
          if (to instanceof HTMLCanvasElement) {
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, canvas:to })
            renderer.setSize( to.width, to.height )
          } else {
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true })
            renderer.setSize( to.clientWidth, to.clientHeight )
            to.appendChild(renderer.domElement)
          }
          renderer.setPixelRatio( window.devicePixelRatio )
          me._renderer = renderer
          return renderer
        },
        disposeChildObject: function(obj) {
          while(obj.children.length > 0){ 
            this.disposeChildObject(obj.children[0])
            obj.remove(obj.children[0]);
          }
          if(obj.geometry) obj.geometry.dispose()

          if(obj.material){ 
            Object.keys(obj.material).forEach(prop => {
              if(!obj.material[prop])
                return         
              if(typeof obj.material[prop].dispose === 'function')
                obj.material[prop].dispose()
            })
            obj.material.dispose()
          }
        },
        parseVec3: function(xyz) {
          let V
          if (xyz instanceof THREE.Vector3) {
            V = xyz
          } else
          if (xyz == null) {
            V = new THREE.Vector3()
          } else {
            const pos = this.parsePos(xyz)
            if (pos == null) {
              return null
            }
            V = new THREE.Vector3(pos.x, pos.y, pos.z)
          }
          return V
        },
        parsePos: function(xyz) {
          let pos = {x:0,y:0,z:0}
          if (Array.isArray(xyz) && xyz.length === 3) {
            pos.x = xyz[0]
            pos.y = xyz[1]
            pos.z = xyz[2]
          } else
          if (!!xyz && typeof xyz === "object" && xyz.x != null && xyz.y != null && xyz.z != null) {
            pos.x = ( typeof xyz.x == 'function' ) ? xyz.x() : xyz.x
            pos.y = ( typeof xyz.y == 'function' ) ? xyz.y() : xyz.y
            pos.z = ( typeof xyz.z == 'function' ) ? xyz.z() : xyz.z
          } else {
            pos = null
          }
          return pos
        },
        parseQuat: function(xyzw) {
          let quat = {x:0,y:0,z:0,w:0}
          if (Array.isArray(xyzw) && xyzw.length === 4) {
            quat.x = xyzw[0]
            quat.y = xyzw[1]
            quat.z = xyzw[2]
            quat.w = xyzw[3]
          } else
          if (!!xyzw && typeof xyzw === "object" && xyzw.x != null && xyzw.y != null && xyzw.z != null && xyzw.w != null) {
            quat.x = ( typeof xyzw.x == 'function' ) ? xyzw.x() : xyzw.x
            quat.y = ( typeof xyzw.y == 'function' ) ? xyzw.y() : xyzw.y
            quat.z = ( typeof xyzw.z == 'function' ) ? xyzw.z() : xyzw.z
            quat.w = ( typeof xyzw.w == 'function' ) ? xyzw.w() : xyzw.w
          } else {
            quat = null
          }
          return quat
        },
        resolveProp: function(obj, keylist) {
          const propMap = sys._weykthreejs.propMap
          Object.keys(keylist).forEach(index => {
            let key = keylist[index]
            if (obj != null) {
              if (propMap[key] != null) {
                key = propMap[key]
              }
              if (key != null) {
                obj = obj[key]
              }
            }
          })
          return obj
        },
        ck: function() {
          if (THREE == null && typeof window.THREE === 'undefined' && sys.__v0['THREE'] == null) {
            throw new Error('three.jsが読み込まれていません')
          }
          if (THREE == null) {
            if (typeof window.THREE !== 'undefined') {
              THREE = window.THREE
            } else
            if (sys.__v0['THREE'] != null) {
              THREE = sys.__v0['THREE']
            }
          }
          if (sys.__v0['THREE'] == null) {
            sys.__v0['THREE'] = THREE
          }
        }
      }
      // オブジェクトを初期化
      sys.__v0['THREE'] = null
    }
  },
  // @定数・変数
  'THREE': {type: 'const', value: ''}, // @THREE
  'TJSベースURL': {type: 'var', value: 'https://cdn.skypack.dev/three@0.128.0'}, // @TJSべーすURL
  // @ライブラリ・プラグイン
  'TJSライブラリ読込後': { // @ThreeJSのライブラリを動的に読み込む // @TJSらいぶらりよみこみご
    type: 'func',
    josi: [['に']],
    pure: true,
    fn: function (callback, sys) {
      if (!sys._weykthreejs) return null
      if (THREE == null && typeof window.THREE === 'undefined' && sys.__v0['THREE'] == null) {
        const url = sys.__findVar('TJSベースURL','.') + '/build/three.module.js'
        const promise = import(url)
        promise.then(module => {
          THREE = Object.assign({}, module)
          sys._weykthreejs.ck()
          callback(true)
        })
        promise.catch(err => {
          callback(false)
        })
      } else {
        sys._weykthreejs.ck()
        callback(true)
      }
    },
    return_none: true
  },
  'TJSプラグイン読込後': { // @ThreeJSのプラグインを動的に読み込む // @TJSぷらぐいんよみこみご
    type: 'func',
    josi: [['に'], ['を']],
    pure: true,
    fn: function (callback, plugins, sys) {
      if (!sys._weykthreejs) return null
      const l=plugins.length
      if (l === 0) {
        callback()
        return
      }
      const callbacks = (function (callback, total) {
        let count = 0
        return function (success) {
          count+=1
          if (count === total) {
            callback()
          }
        }
      })(callback, l)
      for (let i=0;i < l;i++) {
        const name = plugins[i]
        if (name === "libs/ammo.wasm.js") {
          const script = document.createElement('script')
          script.onload = function () {
            script.onload = null
            script.onerror = null
            script.parentNode.removeChild(script)
            callbacks(true)
          }
          script.onerror = function () {
            script.onload = null
            script.onerror = null
            script.parentNode.removeChild(script)
            callbacks(false)
          }
          script.src = sys.__findVar('TJSベースURL','.') + '/examples/js/'+name
          document.querySelector('BODY').appendChild(script)
        } else {
          const url = sys.__findVar('TJSベースURL','.') + '/examples/jsm/'+name
          const promise = import(url)
          promise.then(module => {
            Object.assign(THREE, module)
            callbacks(true)
          })
          promise.catch(err => {
            callbacks(false)
          })
        }
      }
    },
    return_none: true
  },
  // @ThreeJS操作
  'TJS全消去': { // @ThreeJSの作成済みのオブジェクトを全て破棄する // @TJSぜんしょうきょ
    type: 'func',
    josi: [],
    pure: true,
    fn: function (sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.clearAll()
    },
    return_none: true
  },
  'TJS描画準備': { // @指定したDOMのIDに対する描画を準備し、描画オブジェクトを返す // @TJSびょうがじゅんび
    type: 'func',
    josi: [['に','へ']],
    pure: true,
    fn: function (to, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof to === 'string')
        {to = document.querySelector(to) || document.getElementById(to)}
      if (!to) throw new Error('TJS描画準備に指定した描画先に誤りがあります')

      return sys._weykthreejs.setupRenderer(to)
    }
  },
  'TJS描画': { // @指定した描画オブジェクトに対してシーン・カメラで描画する // @TJSびょうが
    type: 'func',
    josi: [['に'],['を'],['で']],
    pure: true,
    fn: function (renderer, scene, camera, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      renderer.render( scene, camera )
      return null
    }
  },
  'TJSシーン作成': { // @ThreeJSのシーンを作成し、シーンオブジェクトを返す // @TJSしーんさくせい
    type: 'func',
    josi: [],
    pure: true,
    fn: function (sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const scene = new THREE.Scene()
      if (scene === null) {
        throw new Error('シーンを作成できません')
      }
      sys._weykthreejs._scene = scene
      sys._weykthreejs._scene_list.push(scene)
      return scene
    }
  },
  'TJSグループ作成': { // @ThreeJSのグループを作成して返す // @TJSぐるーぷさくせい
    type: 'func',
    josi: [],
    pure: true,
    fn: function (sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const group = new THREE.Group()
      if (group === null) {
        throw new Error('グループを作成できません')
      }
      return group
    }
  },
  'TJS背景設定': { // @指定したシーンの背景を設定する // @TJSはいけいせってい
    type: 'func',
    josi: [['に','へ'],['を']],
    pure: true,
    fn: function (scene, obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (obj instanceof Number) { obj = new THREE.Color(obj) }
      scene.background = obj
    },
    return_none: true
  },
  'TJS霧効果設定': { // @指定したシーンに霧の効果を設定する // @TJSきりこうかせってい
    type: 'func',
    josi: [['に','へ'],['を']],
    pure: true,
    fn: function (scene, fog, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      scene.fog = fog
    },
    return_none: true
  },
  'TJSクリア': { // @指定したレンダリングのクリアする // @TJSくりあ
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (renderer, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      renderer.clear()
    },
    return_none: true
  },
  'TJSクリア色設定': { // @指定したレンダリングの際にクリアする色として使用する色を設定する // @TJSくりあしょくせってい
    type: 'func',
    josi: [['に','へ'],['を']],
    pure: true,
    fn: function (renderer, color, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      renderer.setClearColor(color)
    },
    return_none: true
  },
  'TJSクリア透過設定': { // @指定したレンダリングの際にクリアする色の透過度を設定する // @TJSくりあとうかせってい
    type: 'func',
    josi: [['に','へ'],['を']],
    pure: true,
    fn: function (renderer, alpha, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      renderer.setClearAlpha(alpha)
    },
    return_none: true
  },
  'TJS影処理有効': { // @影の投影処理を有効にする // @TJSかげしょりゆうこう
    type: 'func',
    josi: [['の','を']],
    pure: true,
    fn: function (renderer, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      renderer.shadowMap.enabled = true
    },
    return_none: true
  },
  'TJS影処理無効': { // @影の投影処理を無効にする // @TJSかげしょりむこう
    type: 'func',
    josi: [['の','を']],
    pure: true,
    fn: function (renderer, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      renderer.shadowMap.enabled = false
    },
    return_none: true
  },
  'TJS影処理取得': { // @影の投影処理を有効・無効を取得して返す // @TJSかげしょりしゅとく
    type: 'func',
    josi: [['の','から']],
    pure: true,
    fn: function (renderer, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return renderer.shadowMap.enabled
    },
    return_none: false
  },
  // @基本型操作
  'TJS四元数作成': { // @四元数(quotanion)を作成して返す // @TJSしげんすうさくせい
    type: 'func',
    josi: [],
    pure: true,
    fn: function (sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.Quaternion()
    },
    return_none: false
  },
  'TJS四元数アングル取得': { // @四元数を基準として指定した３次元ベクトルとの角度を計算して返す // @TJSしげんすうあんぐるしゅとく
    type: 'func',
    josi: [['から'],['の']],
    pure: true,
    fn: function (qua, xyz, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const pos = sys._weykthreejs.parsePos(xyz)
      if (pos === null) {
        throw new Error(`方向を配列で指定してください([x, y, z]:${typeof xyz}:${xyz.length})`)
      }
      const V = new THREE.Quaternion(xyz[0], xyz[1], xyz[2],0)
      let angle = qua.angleTo(V)
      return angle
    },
    return_none: false
  },
  'TJSVec3': { // @ThreeJsのVector3を作成して返す // @TJSVec3
    type: 'func',
    josi: [['の','で','から']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (opts == null) {
        return new THREE.Vector3()
      }
      const pos = sys._weykthreejs.parsePos(opts)
      if (pos == null) {
        throw new Error('Vector3の作成の際に不明な引数が指定されました')
      }
      return new THREE.Vector3(pos.x, pos.y, pos.z)
    },
    return_none: false
  },
  'TJSVec2設定': { // @Vector2に値を設定する // @TJSVec2せってい
    type: 'func',
    josi: [['の'],['に'],['を']],
    pure: true,
    fn: function (obj, props, xy, sys) {
      if (sys == null) { throw new Error('システム内部引数"sys"がありません。引数が不足しています') }
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (obj != null) {
        obj = sys._weykthreejs.resolveProp(obj ,props)
      } else {
        obj = props
      }
      if (xy != null && xy.x != null && xy.y != null) {
        obj.set(xy.x, xy.y)
      } else
      if (Array.isArray(xy) && xy.length === 2) {
        obj.set(xy[0], xy[1])
      } else {
        throw new Error('Vector2への設定の際に不明な引数が指定されました')
      }
    },
    return_none: true
  },
  'TJS加算': { // @Vec3にVec3を加算する // @TJSかさん
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (v, a, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      v.add(a)
    },
    return_none: true
  },
  'TJSスカラー乗算': { // @Vec3をスカラーで乗算する // @TJSすからーじょうざん
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (v, a, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      v.multiplyScalar(a)
    },
    return_none: true
  },
  'TJS四元数適用': { // @なにかに対して四元数(quotanion)を適用すて姿勢を更新する // @TJSしげんすうてきよう
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (obj, xyzw, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const quat = sys._weykthreejs.parseQuat(xyzw)
      if (quat === null) {
        throw new Error(`四元数を配列で指定してください([x, y, z, w]:${typeof xyzw}:${xyzw.length})`)
      }
      const Q = new THREE.Quaternion(quat.x, quat.y, quat.z, quat.w)
      obj.applyQuaternion(Q)
    },
    return_none: true
  },
  'TJSマトリクス適用': { // @なにかに対してマトリクスを適用して位置・姿勢を更新する // @TJSまとりくすてきよう
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (obj, mat, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (mat instanceof THREE.Matrix3) {
        obj.applyMatrix3(mat)
      } else
      if (mat instanceof THREE.Matrix4) {
        obj.applyMatrix4(mat)
      } else {
        throw new Error(`適用するマトリクスはMatrix3またはMatrix4を指定してください`)
      }
    },
    return_none: true
  },
  // @共通操作
  'TJS位置設定': { // @positionを持つなにかに対して指定した座標に配置する // @TJSいちせってい
    type: 'func',
    josi: [['を'],['に']],
    pure: true,
    fn: function (obj, xyz, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const pos = sys._weykthreejs.parsePos(xyz)
      if (pos === null) {
        throw new Error(`座標を配列で指定してください([x, y, z]:${typeof xyz}:${xyz.length})`)
      }
      obj.position.set(pos.x, pos.y, pos.z)
    },
    return_none: true
  },
  'TJS位置取得': { // @positionを持つなにかから座標の情報を得る // @TJSいちしゅとく
    type: 'func',
    josi: [['から','の']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return obj.position
    },
    return_none: false
  },
  'TJSワールド位置取得': { // @位置(position)を持つなにかからワールドでのその情報を得る // @TJSわーるどいちしゅとく
    type: 'func',
    josi: [['から','の'],['に','へ']],
    pure: true,
    fn: function (obj, pos, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.getWorldPosition(pos)
    },
    return_none: true
  },
  'TJSワールドマトリクス取得': { // @ワールドマトリクスを持つなにかからワールドマトリクスを得る // @TJSわーるどまとりくすしゅとく
    type: 'func',
    josi: [['から','の']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return obj.matrixWorld
    },
    return_none: false
  },
  'TJS四元数設定': { // @四元数(quotanion)を持つなにかに対して指定した姿勢を設定する // @TJSしげんすうせってい
    type: 'func',
    josi: [['を'],['に']],
    pure: true,
    fn: function (obj, xyzw, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const quat = sys._weykthreejs.parseQuat(xyzw)
      if (quat === null) {
        throw new Error(`四元数を配列で指定してください([x, y, z, w]:${typeof xyzw}:${xyzw.length})`)
      }
      obj.quaternion.set(quat.x, quat.y, quat.z, quat.w)
    },
    return_none: true
  },
  'TJS四元数取得': { // @四元数(quotanion)を持つなにかからその情報を得る // @TJSしげんすうしゅとく
    type: 'func',
    josi: [['から','の']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return obj.quaternion
    },
    return_none: false
  },
  'TJSワールド四元数取得': { // @四元数(quotanion)を持つなにかからワールドでのその情報を得る // @TJSわーるどしげんすうしゅとく
    type: 'func',
    josi: [['から','の'],['に','へ']],
    pure: true,
    fn: function (obj, quat, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.getWorldQuaternion(quat)
    },
    return_none: true
  },
  'TJSワールド方向取得': { // @方向(direction)を持つなにかからワールドでのその情報を得る // @TJSわーるどほうこうしゅとく
    type: 'func',
    josi: [['から','の'],['に','へ']],
    pure: true,
    fn: function (obj, vec, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.getWorldDirection(vec)
    },
    return_none: true
  },
  'TJSサイズ設定': { // @setSizeを持つオブジェクトにサイズの設定を行う // @TJSさいずせってい
    type: 'func',
    josi: [['に'],['を','へ']],
    pure: true,
    fn: function (obj, size, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (!Array.isArray(size) || size.length !== 2) {
        throw new Error('設定するサイズを配列で指定してください([w,h])')
      }
      obj.setSize(size[0], size[1])
    },
    return_none: true
  },
  'TJS拡大': { // @scaleを持つオブジェクトにスケールの設定を行う // @TJSかくだい
    type: 'func',
    josi: [['を'],['で','に']],
    pure: true,
    fn: function (obj, scale, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (!Array.isArray(scale) || scale.length !== 3) {
        throw new Error('拡大する倍率を配列で指定してください([x,y,z])')
      }
      obj.scale(scale[0], scale[1], scale[2])
    },
    return_none: true
  },
  'TJS移動': { // @translateを持つオブジェクトを平行移動する // @TJS移動
    type: 'func',
    josi: [['を'],['で','に'],['だけ']],
    pure: true,
    fn: function (obj, axis, distance, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (distance == null) {
        axis = sys._weykthreejs.parsePos(axis)
        if (axis == null) {
          throw new Error('移動する先を配列で指定してください([x,y,z])')
        }
        obj.translate(axis.x, axis.y, axis.z)
      } else {
        axis = sys._weykthreejs.parseVec3(axis)
        if (axis == null) {
          throw new Error('移動する方向(軸)を配列で指定してください([x,y,z])')
        }
        obj.translateOnAxis( axis, distance )
      }
    },
    return_none: true
  },
  'TJS表示': { // @visibleを持つオブジェクトのvisibleにtrueを設定する // @TJSひょうじ
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.visible = true
    },
    return_none: true
  },
  'TJS非表示': { // @visibleを持つオブジェクトのvisibleにfalseを設定する // @TJSひひょうじ
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.visible = false
    },
    return_none: true
  },
  'TJS有効化': { // @なにかを有効にする // @TJSゆうこうか
    type: 'func',
    josi: [['の','を']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.enabled = true
    },
    return_none: true
  },
  'TJS無効化': { // @なにかを無効にする // @TJSむこうか
    type: 'func',
    josi: [['の','を']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.enabled = false
    },
    return_none: true
  },
  'TJSトラバース': { // @traverse可能ななにかに対してtraverseする // @TJとらばーす
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (callback, obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.traverse(callback)
    },
    return_none: true
  },
  'TJS影受設定': { // @receiveShadowを持つオブジェクトにその値を設定する // @TJSかげうけせってい
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (obj, flag, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.receiveShadow = !!flag
    },
    return_none: true
  },
  'TJS影受取得': { // @receiveShadowを持つオブジェクトからその値を取得する // @TJSかげうけしゅとく
    type: 'func',
    josi: [['から','の']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return obj.receiveShadow
    },
    return_none: false
  },
  'TJS影投設定': { // @castShadowを持つオブジェクトにその値を設定する // @TJSかげなげせってい
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (obj, flag, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.castShadow = !!flag
    },
    return_none: true
  },
  'TJS影投取得': { // @castShadowを持つオブジェクトからその値を取得する // @TJSかげなげしゅとく
    type: 'func',
    josi: [['から','の']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return obj.castShadow
    },
    return_none: false
  },
  'TJS登場': { // @指定したシーンやグループに指定したなにかを追加する // @TJSとうじょう
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (scene, obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      scene.add(obj)
    },
    return_none: true
  },
  'TJS退場': { // @指定したシーンやグループから指定したなにかを削除する // @TJSたいじょう
    type: 'func',
    josi: [['から'],['を']],
    pure: true,
    fn: function (scene, obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      scene.remove(obj)
    },
    return_none: true
  },
  'TJS自主退場': { // @指定したなにかをそれが属している親から削除する // @TJSじしゅたいじょう
    type: 'func',
    josi: [['を','が']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      obj.removeFromParent()
    },
    return_none: true
  },
  // @カメラ
  'TJS透視投影カメラ作成': { // @透視投影カメラを作成しそのオブジェクトを返す // @TJSとうしとうえいかめらさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (param, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (!Array.isArray(param) || param.length !== 4) {
        throw new Error('カメラの仕様を配列で指定してください([視野角(度), アスペクト比, 最近距離, 最遠距離])')
      }
      const camera = new THREE.PerspectiveCamera(param[0], param[1], param[2], param[3])
      if (camera === null) {
        throw new Error('透視投影カメラを作成できません')
      }
      sys._weykthreejs._camera = camera
      return camera
    }
  },
  'TJS環境撮影カメラ作成': { // @環境マップ撮影用のCubeカメラを作成しそのオブジェクトを返す // @TJSかんきょうさつえいかめらさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (param, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (!Array.isArray(param) || param.length !== 3) {
        throw new Error('カメラの仕様を配列で指定してください([最近距離, 最遠距離, 環境撮影用レンダーターゲット])')
      }
      const camera = new THREE.CubeCamera(param[0], param[1], param[2], param[3])
      if (camera === null) {
        throw new Error('環境撮影カメラを作成できません')
      }
      sys._weykthreejs._camera = camera
      return camera
    }
  },
  'TJSカメラ上方設定': { // @カメラの上として扱う方向を指定する // @TJSかめらじょうほうせってい
    type: 'func',
    josi: [['を'],['に']],
    pure: true,
    fn: function (camera, vec, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      let dir = []
      if (typeof vec == "string") {
        if (vec == "+X")      dir = [  1.0,  0.0,  0.0]
        else if (vec == "-X") dir = [ -1.0,  0.0,  0.0]
        else if (vec == "+Y") dir = [  0.0,  1.0,  0.0]
        else if (vec == "-Y") dir = [  0.0, -1.0,  0.0]
        else if (vec == "+Z") dir = [  0.0,  0.0,  1.0]
        else if (vec == "-Z") dir = [  0.0,  0.0, -1.0]
        else {
          throw new Error('カメラの上方向を表す文字列が正しくありません。文字列もしくは単位ベクトルの配列で指定してください("+","-"と"X","Y","Z"の組み合わせ or [x, y, z])')
        }
      } else {
        const pos = sys._weykthreejs.parsePos(xyz)
        if (pos === null) {
          throw new Error('カメラの上方向を表す文字列が正しくありません。文字列もしくは単位ベクトルの配列で指定してください("+","-"と"X","Y","Z"の組み合わせ or [x, y, z])')
        }
        dir[0] = pos.x
        dir[1] = pos.y
        dir[2] = pos.z
      }
      camera.up.x = dir[0]
      camera.up.y = dir[1]
      camera.up.z = dir[2]
      return null
    }
  },
  'TJS投影マトリクス更新': { // @カメラのマトリクスを更新する // @TJSとうえいまとりくすこうしん
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (camera, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      camera.updateProjectionMatrix()
    },
    return_none: true
  },
  'TJS視点設定': { // @カメラを向ける先の座標を指定する。カメラ以外にも使用可能 // @TJSしてんせってい
    type: 'func',
    josi: [['を'],['に','へ']],
    pure: true,
    fn: function (camera, at, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const pos = sys._weykthreejs.parsePos(at)
      if (pos === null) {
        throw new Error('カメラを向ける先の座標を指定してください([x,y,z])')
      }
      camera.lookAt(pos.x, pos.y, pos.z)
    },
    return_none: true
  },
  'TJSカメラ最近距離設定': { // @指定したカメラの視界となる最小の距離を設定する。 // @TJSかめらさいきんきょりせってい
    type: 'func',
    josi: [['の'],['に'],['を']],
    pure: true,
    fn: function (obj, camera, near, sys) {
      if (sys == null) { throw new Error('システム内部引数"sys"がありません。引数が不足しています') }
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (camera.near == null) {
        obj = sys._weykthreejs.resolveProp(obj ,camera)
      }
      obj.near = near
    },
    return_none: true
  },
  'TJSカメラ矩形距離設定': { // @指定したカメラの視界範囲の左上右下の距離を設定する。 // @TJSかめらくけいきょりせってい
    type: 'func',
    josi: [['の'],['に'],['を']],
    pure: true,
    fn: function (obj, camera, rect, sys) {
      if (sys == null) { throw new Error('システム内部引数"sys"がありません。引数が不足しています') }
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (camera.left == null || camera.right == null || camera.top == null || camera.bottom == null) {
        obj = sys._weykthreejs.resolveProp(obj ,camera)
      }
      if (Array.isArray(rect) && rect.length === 4) {
        obj.left = rect[0]
        obj.top = rect[1]
        obj.right = rect[2]
        obj.bottom = rect[3]
      } else
      if (obj.left != null && obj.right != null && obj.top != null && obj.bottom != null) {
        obj.left = rect.left
        obj.top = rect.top
        obj.right = rect.right
        obj.bottom = rect.bottom
      } else {
        throw new Error('矩形の指定が正しくありません。要素４つの配列([left, top, right, bottom])で指定して下さい')
      }
    },
    return_none: true
  },
  'TJSカメラ最遠距離設定': { // @指定したカメラの視界となる最大の距離を設定する。 // @TJSかめらさいえんきょりせってい
    type: 'func',
    josi: [['の'],['に'],['を']],
    pure: true,
    fn: function (obj, camera, far, sys) {
      if (sys == null) { throw new Error('システム内部引数"sys"がありません。引数が不足しています') }
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (camera.far == null) {
        obj = sys._weykthreejs.resolveProp(obj ,camera)
      }
      obj.far = far
    },
    return_none: true
  },
  'TJSカメラ視野角設定': { // @指定した光源のシャドー光源が角度を設定する。 // @TJSかめらしやかくせってい
    type: 'func',
    josi: [['の'],['に'],['を']],
    pure: true,
    fn: function (obj, camera, angle, sys) {
      if (sys == null) { throw new Error('システム内部引数"sys"がありません。引数が不足しています') }
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (camera.angle == null) {
        obj = sys._weykthreejs.resolveProp(obj ,camera)
      }
      obj.angle = angle
    },
    return_none: true
  },
  'TJS環境撮影用レンダーターゲット作成': { // @環境マップ撮影時の撮影先となるレンダーターゲットを作成しそのオブジェクトを返す // @TJSかんきょうさつえいようれんだーたーげっとさくせい
    type: 'func',
    josi: [['を'],['で']],
    pure: true,
    fn: function (size, opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.WebGLCubeRenderTarget(size, opts)
    },
    return_none: false
  },
  'TJS環境カメラ撮影': { // @指定した描画オブジェクトに対してシーン・カメラで描画する // @TJSびょうが
    type: 'func',
    josi: [['に'],['を'],['で']],
    pure: true,
    fn: function (renderer, scene, camera, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      camera.update(renderer, scene)
    },
    return_none: true
  },
  // @光源・シャドー光源
  'TJS環境光源作成': { // @環境光の光源を作成する // @TJSかんきょうこうげんさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (color, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.AmbientLight(color)
    },
    return_none: false
  },
  'TJS点光源作成': { // @点の光源を作成する // @TJSてんこうげんさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (param, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (!Array.isArray(param) || param.length !== 4) {
        throw new Error('点光源の仕様を配列で指定してください([色, 強度, 到達距離, 減衰率])')
      }
      return new THREE.PointLight(param[0], param[1], param[2], param[3])
    }
  },
  'TJS平行光源作成': { // @平行な光が降り注ぐ光源を作成する // @TJSへいこうこうげんさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (param, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (!Array.isArray(param) || param.length !== 2) {
        throw new Error('平行光源の仕様を配列で指定してください([色, 強度])')
      }
      return new THREE.DirectionalLight(param[0], param[1])
    }
  },
  'TJSスポット光源作成': { // @スポット光源を作成する // @TJSすぽっとこうさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (param, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (!Array.isArray(param) || param.length !== 6) {
        throw new Error('スポット光源の仕様を配列で指定してください([色, 強度, 到達距離, 放射角, 拡散減衰率, 距離減衰係数])')
      }
      return new THREE.SpotLight(param[0], param[1], param[2], param[3], param[4], param[5])
    }
  },
  'TJSマップサイズ設定': { // @指定したシャドー光源のシャドーマップのサイズを設定する。２のべき乗にすること // @TJSまっぷさいずせってい
    type: 'func',
    josi: [['の'],['に'],['を']],
    pure: true,
    fn: function (obj, lightshadow, wh, sys) {
      if (sys == null) { throw new Error('システム内部引数"sys"がありません。引数が不足しています') }
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (!Array.isArray(wh) || wh.length !== 2) {
        throw new Error('サイズは[幅,高さ]の形の要素２個の配列で指定して下さい')
      }
      if (lightshadow.mapSize == null) {
        obj = sys._weykthreejs.resolveProp(obj ,lightshadow)
      }
      obj.mapSize.width = wh[0]
      obj.mapSize.height = wh[1]
    },
    return_none: true
  },
  // @構造(ジオメトリ)に対する操作
  'TJS属性設定': { // @ジオメトリに指定した名前の属性を属性バッファを設定する // @TJSぞくせいせってい
    type: 'func',
    josi: [['の'],['に'],['を']],
    pure: true,
    fn: function (geometory, attr, buf, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      geometory.setAttribute(attr, buf)
    },
    return_none: true
  },
  'TJSインデックス設定': { // @ジオメトリにインデックスを設定する。属性の参照がインデックス経由になる // @TJSいんでっくすせってい
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (geometory, index, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      geometory.setIndex(index)
    },
    return_none: true
  },
  'TJS境界箱計算': { // @指定したジオメトリの境界を箱型として計算する // @TJSきょいかいはこけいさん
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (geometory, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      geometory.computeBoundingBox()
    },
    return_none: true
  },
  'TJS境界球計算': { // @指定したジオメトリの境界を球型として計算する // @TJSきょいかいきゅうけいさん
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (geometory, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      geometory.computeBoundingSphere()
    },
    return_none: true
  },
  'TJS法線計算': { // @指定したジオメトリの法線を計算する // @TJSほうせんけいさん
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (geometory, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      geometory.computeVertexNormals()
    },
    return_none: true
  },
  'TJS回転': { // @ジオメトリを指定した軸に沿って回転する // @TJSかいてん
    type: 'func',
    josi: [['を'],['で'],['だけ']],
    pure: true,
    fn: function (geometory, axis, radius, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (axis === 'X' || axis === 'x') {
        geometory.rotateX(radius)
      } else
      if (axis === 'Y' || axis === 'y') {
        geometory.rotateY(radius)
      } else
      if (axis === 'Z' || axis === 'z') {
        geometory.rotateZ(radius)
      } else {
        throw new Error('回転の軸はXかYかZを指定して下さい')
      }
    },
    return_none: true
  },
  // @属性バッファ・バッファ
  'TJS属性バッファ作成': { // @ジオメトリの属性に設定するバッファを作成して返す。型付配列と１件分のデータ数を指定する // @TJSぞくせいばっふぁさくせい
    type: 'func',
    josi: [['から','を'],['の','で']],
    pure: true,
    fn: function (ary, num, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.BufferAttribute(ary,num)
    },
    return_none: false
  },
  'TJSインターリーブバッファ作成': { // @インターリーブのあるバッファを作成して返す。型付配列と１頂点毎のデータ数を指定する // @TJSいんたーりーぶばっふぁさくせい
    type: 'func',
    josi: [['から','を'],['の','で']],
    pure: true,
    fn: function (ary, stride, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.InterleavedBuffer(ary,stride)
    },
    return_none: false
  },
  'TJSインターリーブ属性作成': { // @インターリーブバッファから属性バッファを作成して返す。インターリーブバッファとオフセットと１件分のデータ数を指定する // @TJSいんたーりーぶぞくせいさくせい
    type: 'func',
    josi: [['で'],['から'],['の']],
    pure: true,
    fn: function (buf, off, num, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.InterleavedBufferAttribute(buf,num,off)
    },
    return_none: false
  },
  'TJS変更有無設定': { // @属性バッファ・インターリーブバッファに変更の有無を設定する // @TJSへんこううむせってい
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (buf, opt, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      let type = opt
      if (typeof type === "string") {
        if (opt=="頻繁" || opt=="動的" || opt=="有り" || opt=="有" || opt=="Dynamic" || opt=="DynamicDrawUsage") {
          type=THREE["DynamicDrawUsage"]
        } else
        if (opt=="静的" || opt=="無し" || opt=="無" || opt=="Static" || opt=="StaticDrawUsage") {
          type=THREE["StaticDrawUsage"]
        } else {
          type = null
        }
      }
      buf.setUsage(type)
    },
    return_none: true
  },
  // @基本構造(ジオメトリ)
  'TJS空構造作成': { // @空のジオメトリを作成して返す // @TJSからこうぞうさくせい
    type: 'func',
    josi: [],
    pure: true,
    fn: function (sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.BufferGeometry()
    }
  },
  'TJS板作成': { // @板(平面)のジオメトリを作成して返す // @TJSいたさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const width = opts["幅"] || opts["W"] || opts["width"] || 1.0
      const height = opts["高さ"] || opts["H"] || 1.0
      const widthSegments = opts["横分割数"] || opts["heightSegments"] || 1
      const heightSegments = opts["縦分割数"] || opts["heightSegments"] || 1
      const isBuffered = opts["バッファ"] || opts["buffer"] || false
      if (isBuffered) {
        return new THREE.PlaneBufferGeometry(width, height, widthSegments, heightSegments)
      }
      return new THREE.PlaneGeometry(width, height, widthSegments, heightSegments)
    }
  },
  'TJS箱作成': { // @箱(直方体)のジオメトリを作成して返す // @TJSはこさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const width = opts["幅"] || opts["W"] || opts["width"] || 1.0
      const height = opts["高さ"] || opts["高"] || opts["H"] || opts["height"] || 1.0
      const depth = opts["奥行"] || opts["D"] || opts["depth"] || 1.0
      const widthSegments = opts["横分割数"] || opts["heightSegments"] || 1
      const heightSegments = opts["縦分割数"] || opts["heightSegments"] || 1
      const depthSegments = opts["奥行分割数"] || opts["depthSegments"] || 1
      const isBuffered = opts["バッファ"] || opts["buffer"] || false
      if (isBuffered) {
        return new THREE.BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)
      }
      return new THREE.BoxGeometry(width, height, depth, widthSegments, heightSegments, depthSegments)
    }
  },
  'TJS球体作成': { // @球体(多面体)のジオメトリを作成して返す // @TJSきゅうたいさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const radius = opts["半径"] || opts["R"] || opts["radius"] || 1.0
      const widthSegments = opts["横分割数"] || opts["widthSegments"] || 8
      const heightSegments = opts["縦分割数"] || opts["heightSegments"] || 6
      const phiStart = opts["横開始位置"] || opts["phiStart"] || 0
      const phiLength =  opts["横長"] || opts["phiLength"] || (Math.PI * 2)
      const thettaStart = opts["縦開始位置"] || opts["thettaStart"] || 0
      const thetaLength = opts["縦長"] || opts["thetaLength"] || (Math.PI * 2)
      const isBuffered = opts["バッファ"] || opts["buffer"] || false
      if (isBuffered) {
        return new THREE.SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thettaStart,thetaLength)
      }
      return new THREE.SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thettaStart,thetaLength)
    }
  },
  'TJSシリンダ体作成': { // @シリンダのジオメトリを作成して返す // @TJSしりんだたいさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const radiusTop = opts["上半径"] || opts["天半径"] || opts["radiusTop"] || opts["半径"] || opts["R"] ||  opts["radius"] || 1.0
      const radiusBottom = opts["下半径"] || opts["底半径"] || opts["radiusBottom"] || opts["半径"] || opts["R"] || opts["radius"] || 1.0
      const height = opts["高"] || opts["縦"] || opts["height"] || 1.0
      const radialSegments = opts["円分割数"] || opts["radialSegments"] || 8
      const heightSegments = opts["縦分割数"] || opts["heightSegments"] || 1
      const openEnd = !!(opts["上下開放"] || opts["openEnd"] || false)
      const thetaStart = opts["円開始位置"] || opts["thetaStart"] || 0
      const thetaLength = opts["円長"] || opts["thetaLength"] || (Math.PI * 2)
      const isBuffered = opts["バッファ"] || opts["buffer"] || false
      if (isBuffered) {
        return new THREE.CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnd,thetaStart,thetaLength)
      }
      return new THREE.CylinderGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnd,thetaStart,thetaLength)
    }
  },
  // @マテリアル(質感)
  'TJS基本表面材質作成': { // @mesh用の光源に因らない基本的なmateriaを作成して返す // @TJSきほんひょうめんざしつさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.MeshBasicMaterial(opts)
    }
  },
  'TJS拡散反射材質作成': { // @mesh用の光沢を除く拡散反射するmaterialを作成して返す // @TJSかくさんはんしゃざしつさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.MeshLambertMaterial(opts)
    }
  },
  'TJS光沢拡散反射材質作成': { // @mesh用の光沢を含む拡散反射するmaterialを作成して返す // @TJSこうたくかくさんはんしゃざしつさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.MeshPhongMaterial(opts)
    }
  },
  'TJS標準材質作成': { // @mesh用の標準的な機能を網羅したmateriaを作成して返す // @TJSひょうじゅんざしつさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.MeshStandardMaterial(opts)
    }
  },
  // @メッシュ(質感＋構造)
  'TJSメッシュ作成': { // @meshを作成して返す // @TJSめっしゅさくせい
    type: 'func',
    josi: [['と'],['の']],
    pure: true,
    fn: function (geo, mat, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.Mesh(geo, mat)
    }
  },
  // @テクスチャ
  'TJSテクスチャローダ作成': { // @テクスチャのローダを作成して返す // @TJSてくすちゃろーださくせい
    type: 'func',
    josi: [['を','の','で']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const path = opts["パス"] || opts["path"] || undefined
      const loader = new THREE.TextureLoader()
      if (path) {
        loader.setPath(path)
      }
      return loader
    },
    return_none: false
  },
  'TJSテクスチャ読込': { // @テクスチャを読み込んでそのテクスチャを返す // @TJSてくすしゃよみこみ
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const path = opts["パス"] || opts["path"] || undefined
      const url = opts["URL"] || opts["url"] || ''
      if (typeof url !== 'string') {
        throw new Error('画像のURLを１つ指定してください')
      }
      const ctl = new THREE.TextureLoader()
      if (path) {
        ctl.setPath(path)
      }
      return ctl.load(url)
    },
    return_none: false
  },
  'TJSテクスチャ保障読込': { // @テクスチャを読み込むPromiseを返す // @TJSてくすしゃほしょうよみこみ
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const path = opts["パス"] || opts["path"] || undefined
      const url = opts["URL"] || opts["url"] || ''
      if (typeof url !== 'string') {
        throw new Error('画像のURLを１つ指定してください')
      }
      const ctl = new THREE.TextureLoader()
      if (path) {
        ctl.setPath(path)
      }
      return ctl.loadAsync(url)
    },
    return_none: false
  },
  'TJS立方体テクスチャ読込': { // @立方体状のテクスチャを読み込んでそのテクスチャを返す // @TJSりっぽうたいてくすしゃよみこみ
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const path = opts["パス"] || opts["path"] || undefined
      const url = opts["URL"] || opts["url"]
      if (!Array.isArray(url) || url.length !== 6) {
        throw new Error('画像のURLを配列で6個指定してください(URL:[url1,url2,url3,url4,url5,url6])')
      }
      const ctl = new THREE.CubeTextureLoader()
      if (path) {
        ctl.setPath(path)
      }
      return ctl.load(url)
    },
    return_none: false
  },
  'TJS立方体テクスチャ保障読込': { // @立方体状のテクスチャを読み込むPromiseを返す // @TJSりっぽうたいてくすしゃほしょうよみこみ
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const path = opts["パス"] || opts["path"] || undefined
      const url = opts["URL"] || opts["url"]
      if (!Array.isArray(url) || url.length !== 6) {
        throw new Error('画像のURLを配列で6個指定してください(URL:[url1,url2,url3,url4,url5,url6])')
      }
      const ctl = new THREE.CubeTextureLoader()
      if (path) {
        ctl.setPath(path)
      }
      return ctl.loadAsync(url)
    },
    return_none: false
  },
  'TJSキャンバステクスチャ作成': { // @キャンバスからテクスチャを作成してそのテクスチャを返す // @TJSきゃんばすてくすちゃさくせい
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      const canvas = opts["キャンバス"] || opts["CANVAS"] || opts["canvas"] || undefined
      if (typeof canvas === 'undefined') {
        throw new Error('キャンバスを指定して下さい')
      }
      return new THREE.CanvasTexture(canvas)
    },
    return_none: false
  },
  'TJS読込': { // @なんらかのローダを使用して指定したURLから読み込んで返す // @TJSよみこみ
    type: 'func',
    josi: [['から'],['を']],
    pure: true,
    fn: function (loader, url, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return loader.load(url)
    },
    return_none: false
  },
  'TJS保障読込': { // @なんらかのローダを使用して指定したURLから読み込むPromiseを返す // @TJSほしょうよみこみ
    type: 'func',
    josi: [['から'],['を']],
    pure: true,
    fn: function (loader, url, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return loader.loadAsync(url)
    },
    return_none: false
  },
  // @フォッグ
  'TJSフォッグ作成': { // @霧の効果を作成して返す // @TJSふぉっぐさくせい
    type: 'func',
    josi: [['で'],['から'],['までの']],
    pure: true,
    fn: function (color, near, far, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.Fog(color, near, far)
    },
    return_none: false
  },
  // @レイキャスタ
  'TJSレイキャスタ作成': { // @レイキャスターを作成して返す // @TJSれいきゃすたーさくせい
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.Raycaster()
    },
    return_none: false
  },
  'TJSカメラ起点レイ': { // @レイキャスタをカメラからの視点で設定する // @TJSかめらどうき
    type: 'func',
    josi: [['で'], ['に','を'], ['から']],
    pure: true,
    fn: function (raycaster, coords, camera, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      let V
      if (coords instanceof THREE.Vector2) {
        V = coords
      } else
      if (coords.x != null && coords.y != null) {
        V = new THREE.Vector2(coords.x, coords.y)
      } else
      if (Array.isArray(coords) && coords.length === 2) {
        V = new THREE.Vector2(coords[0], coords[1])
      } else {
        throw new Error('レイを飛ばす位置を-1.0から+1.0に正規化した要素２個の配列で指定して下さい')
      }
      raycaster.setFromCamera( V, camera )
    },
    return_none: true
  },
  'TJSレイ命中取得': { // @対象に対しレイキャスターのレイがヒットした情報を配列で返す // @TJSれいめいちゅうしゅとく
    type: 'func',
    josi: [['で'],['に']],
    pure: true,
    fn: function (raycaster, obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return raycaster.intersectObject(obj)
    },
    return_none: false
  },
  'TJSレイ命中一覧取得': { // @リストの中のレイキャスターのレイがヒットした情報を配列で返す // @TJSれいめいちゅういちらんしゅとく
    type: 'func',
    josi: [['で'],['に']],
    pure: true,
    fn: function (raycaster, lists, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return raycaster.intersectObjects(lists)
    },
    return_none: false
  },
  'TJSレイ原点取得': { // @レイキャスターのレイの原点(起点)を返す // @TJSれいげんてんしゅとく
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (raycaster, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return raycaster.ray.origin
    },
    return_none: false
  },
  'TJSレイ方向取得': { // @レイキャスターのレイの方向を返す // @TJSれいほうこうしゅとく
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (raycaster, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return raycaster.ray.direction
    },
    return_none: false
  },
  // @アニメーション
  'TJSアニメーションミキサー作成': { // @指定したモデルのアニメーションミキサーを作成して返す // @TJSあにめーしょんみきさーさくせい
    type: 'func',
    josi: [['の','から']],
    pure: true,
    fn: function (model, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return new THREE.AnimationMixer(model)
    },
    return_none: false
  },
  'TJSクリップアクション取得': { // @ミキサーから指定のクリップのアクションを取得する // @TJSくりっぷあくしょんしゅとく
    type: 'func',
    josi: [['から'],['の']],
    pure: true,
    fn: function (mixer, clip, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      return mixer.clipAction ( clip )
    },
    return_none: false
  },
  'TJSアクション比重設定': { // @アクションに対して比重を設定する // @TJSあくしょんひじゅうせってい
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (act, w, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      act.setEffectiveWeight(w)
    },
    return_none: true
  },
  'TJSアクション再生時間倍率設定': { // @アクションに再生する時間の倍率を設定する // @TJSあくしょんさいせいじかんばんりつせってい
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (act, w, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      act.setEffectiveWeight(w)
    },
    return_none: true
  },
  'TJSアクション再生': { // @指定したアクションの再生を開始する // @TJSあくしょんさいせい
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (act, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      act.play()
    },
    return_none: true
  },
  'TJSアクション停止': { // @指定したアクションを停止する // @TJSあくしょんていし
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (act, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      act.stop()
    },
    return_none: true
  },
  // @ローダー
  'TJSGLTFローダ作成': { // @glTF形式のモデル用のローダを返す // @TJSGLTFろーださくせい
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.GLTFLoader === 'undefined') {
        throw new Error('GLTFLoader.jsが読み込まれていません')
      }
      const path = opts["パス"] || opts["path"] || undefined
      const draco = opts["DRACO"] || opts["draco"] || undefined
      const loader = new THREE.GLTFLoader()
      if (path) {
        loader.setPath(path)
      }
      if (draco) {
        loader.setDRACOLoader( draco )
      }
      return loader
    },
    return_none: false
  },
  'TJSGLTF保障読込': { // @glTF形式のモデルを読み込むPromiseを返す // @TJSGLTFほしょうよみこみ
    type: 'func',
    josi: [['を']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.GLTFLoader === 'undefined') {
        throw new Error('GLTFLoader.jsが読み込まれていません')
      }
      const path = opts["パス"] || opts["PATH"] || opts["path"] || undefined
      const url = opts["URL"] || opts["url"] || ''
      const draco = opts["DRACO"] || opts["draco"] || undefined
      if (typeof url !== 'string') {
        throw new Error('glTFモデルのURLを１つ指定してください')
      }
      const loader = new THREE.GLTFLoader()
      if (path) {
        loader.setPath(path)
      }
      if (draco) {
        loader.setDRACOLoader( draco )
      }
      return loader.loadAsync(url)
    },
    return_none: false
  },
  'TJSMD2複合キャラクタローダ作成': { // @MD2形式の複合キャラクタのモデル用のローダを返す // @TJSMD2ふくごうきゃらくたろーださくせい
    type: 'func',
    josi: [],
    pure: true,
    fn: function (sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.MD2CharacterComplex === 'undefined') {
        throw new Error('MD2CharacterComplex.jsが読み込まれていません')
      }
      return new THREE.MD2CharacterComplex()
    },
    return_none: false
  },
  // @コントローラ
  'TJS衛星軌道コントローラ作成': { // @OrbitControlerを作成して返す // @TJSえいせいきどうこんとろーらさくせい
    type: 'func',
    josi: [['に'],['の']],
    pure: true,
    fn: function (camera, dom, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.OrbitControls === 'undefined') {
        throw new Error('OrbitControls.jsが読み込まれていません')
      }
      if (dom instanceof THREE.WebGLRenderer || dom instanceof THREE.WebGL1Renderer) {
        dom = dom.domElement
      }
      return new THREE.OrbitControls(camera, dom)
    },
    return_none: false
  },
  'TJS一人称視点コントローラ作成': { // @FirstPersonControlsを作成して返す // @TJSいちにんしょうしてんこんとろーらさくせい
    type: 'func',
    josi: [['に'],['の']],
    pure: true,
    fn: function (camera, dom, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.FirstPersonControls === 'undefined') {
        throw new Error('FirstPersonControls.jsが読み込まれていません')
      }
      if (dom instanceof THREE.WebGLRenderer || dom instanceof THREE.WebGL1Renderer) {
        dom = dom.domElement
      }
      return new THREE.FirstPersonControls(camera, dom)
    },
    return_none: false
  },
  'TJS飛行視点コントローラ作成': { // @FlyControlsを作成して返す // @TJSひこうしてんこんとろーらさくせい
    type: 'func',
    josi: [['に'],['の']],
    pure: true,
    fn: function (camera, dom, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.FlyControls === 'undefined') {
        throw new Error('FlyControls.jsが読み込まれていません')
      }
      if (dom instanceof THREE.WebGLRenderer || dom instanceof THREE.WebGL1Renderer) {
        dom = dom.domElement
      }
      return new THREE.FlyControls(camera, dom)
    }
  },
  'TJS更新': { // @指定したなにかを更新(update)する // @TJSこうしん
    type: 'func',
    josi: [['の','を'],['で']],
    pure: true,
    fn: function (control, delta, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      control.update(delta)
    },
    return_none: true
  },
  // @効果
  'TJS両目効果作成': { // @StereoEffectを作成して返す // @TJSりょうめこうかさくせい
    type: 'func',
    josi: [['に']],
    pure: true,
    fn: function (renderer, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.StereoEffect === 'undefined') {
        throw new Error('StereoEffect.jsが読み込まれていません')
      }
      return new THREE.StereoEffect(renderer)
    },
    return_none: false
  },
  // @ヘルパ
  'TJS軸線ヘルパ作成': { // @長さがlenのAxesHelperを作成して返す // @TJSじくせんへるぱさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (len, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.AxesHelper === "undefined") {
        throw Error('AXESヘルパの機能が見当たりません。')
      }
      return new THREE.AxesHelper(len)
    },
    return_none: false
  },
  'TJSグリッドヘルパ作成': { // @GridHelperを作成して返す // @TJSぐりっどへるぱさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.GridHelper === "undefined") {
        throw Error('Gridヘルパの機能が見当たりません。')
      }
      const size = opts["サイズ"] || opts["範囲"] || opts["size"] || 10
      const divisions = opts["分割数"] || opts["divisions"] || 10
      const colorCenterLine = opts["軸線色"] || opts["colorCenterLine"] || 0x444444
      const colorGrid = opts["グリッド色"] || opts["colorGrid"] || 0x88888
      return new THREE.GridHelper(size, divisions, colorCenterLine, colorGrid)
    },
    return_none: false
  },
  'TJS矢印ヘルパ作成': { // @起点とベクターを指定して矢印を用事するArrowHelperを作成して返す // @TJSやじるしへるぱさくせい
    type: 'func',
    josi: [['の']],
    pure: true,
    fn: function (opts, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.ArrowHelper === "undefined") {
        throw Error('ARROWヘルパの機能が見当たりません。')
      }
      const dir = opts["方向"] || opts["向き"] || opts["向"] || opts["dir"] || new THREE.Vecror3(0,0,1)
      const origin = opts["起点"] || opts["原点"] || opts["origin"] || new THREE.Vecror3(0,0,0)
      const color = opts["色"] || opts["color"] || 0xffff00
      const len = opts["長さ"] || opts["長"] || opts["length"] || 1
      return new THREE.ArrowHelper(dir, origin, len, color)
    },
    return_none: false
  },
  'TJS矢印方向設定': { // @矢印ヘルパの方向を設定する // @TJSやじるしほうこうせってい
    type: 'func',
    josi: [['に'],['を']],
    pure: true,
    fn: function (helper, dir, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      helper.setDirection(dir)
    },
    return_none: true
  },
  'TJSスケルトン付複製': { // @SkeletonUtilの機能でObject3Dをボーン込みで複製して返す // @TJSすけるとんつきふくせい
    type: 'func',
    josi: [['の','を','から']],
    pure: true,
    fn: function (obj, sys) {
      if (!sys._weykthreejs) return null
      sys._weykthreejs.ck()
      if (typeof THREE.SkeletonUtils === "undefined") {
        throw Error('スケルトンユーティリティの機能が見当たりません。')
      }
      return THREE.SkeletonUtils.clone(obj)
    },
    return_none: false
  }
}

if (typeof global === "object" && typeof global.process === "object") {
  module.exports = PluginWeykThree
}

// ブラウザからscriptタグで取り込んだ時、自動で登録する
if (typeof navigator === 'object' && typeof navigator.nako3 === 'object') {
  navigator.nako3.addPluginObject('PluginWeykThree', PluginWeykThree)
}