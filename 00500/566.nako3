### [作品情報]
### タイトル=セル オートマトン シミュレータ(WebGL利用)
### 作者=てぃふと@うぇいく(user_id=2)
### ライセンス=CC0
### 説明=Conwayのゲーム・オブ・ライフや、Langtonのループを見るための環境。ルールを選んでから、既定配置で登録済みのプリセットが順に表示されるので、見たいところでGO。プログラムのライセンスはCC0(PDS扱い)。ただし、ルールや配置データ等はそれぞれの著者がいて権利を持っているので注意。
### 対象バージョン=3.2.14
### URL=
### 種類=wnako
### タグ=
### 更新日時=2021-06-16 20:30:36
###

# Cell automaton Simulator


「全て」を実行速度優先

!「https://n3s.nadesi.com/plain/565.nako3」を取り込む

ルール一覧準備完了はオフ
配置一覧準備完了はオフ
ルール一覧は空配列
配置一覧は空配列

!「https://n3s.nadesi.com/plain/568.nako3」を取り込む
!「https://n3s.nadesi.com/plain/569.nako3」を取り込む


# 設定
画面幅は1200
画面高は1000
ワールドは{
　幅: 1200,
　高: 1000,
　境界ループ:「LOOP」
}

#
# WEBGL更新表示ためのワークエリア

WEBGL用キャンバンスはNULL
ワールド["TEX"]はNULL
全体頂点情報バッファはNULL
表示頂点情報バッファはNULL
更新頂点情報バッファはNULL
部分頂点情報バッファはNULL
更新プログラムはNULL
表示プログラムはNULL
初期化プログラムはNULL
FBリストは空配列
配置中パーツはNULL
表FBは0
裏FBは1-表FB

# 処理効率化のためのキャッシュ
空初期化用テクスチャはNULL

コントロールパネルリストは[
  [[  0,  0], [ 90, 20], "runInfo", "", 0, NULL],
  [[  0, 20], [ 30, 20], "EndButton", "終", 0, "End"],
  [[ 30, 20], [ 20, 20], "StopButton", "⏸", 0, "Stop"],
  [[ 50, 20], [ 20, 20], "StepButton", "⏯", 0, "Step"],
  [[ 70, 20], [ 20, 20], "StartButton", "⏩", 0, "Start"],
  [[ 90,  0], [ 60, 20], "zoomInfo", "", 0, NULL],
  [[ 90, 20], [ 30, 20], "ZoomInButton", "大", 0, "ZoomIn"],
  [[120, 20], [ 30, 20], "ZoomOutButton", "小", 0, "ZoomOut"],
  [[150,  0], [120, 20], "PositionInfo", "", 0, NULL],
  [[150, 20], [ 20, 20], "LeftButton", "➡", 180, "PosLeft"],
  [[170, 20], [ 20, 20], "UpButton", "➡", 270, "PosUp"],
  [[190, 20], [ 20, 20], "DownButton", "➡", 90, "PosDown"],
  [[210, 20], [ 20, 20], "RightButton", "➡", 0, "PosRight"],
  [[230, 20], [ 40, 20], "HomeButton", "原点", 0, "PosHome"],
  [[270,  0], [ 50, 20], "LoopInfo", "", 0, NULL],
  [[270, 20], [ 50, 20], "ChangeLoopButton", "切替", 0, "ChangeLoop"],
  [[320,  0], [ 60, 20], "SpeedInfo", "", 0, NULL],
  [[320, 20], [ 30, 20], "SpeedDownButton", "遅", 0, "SpeedDown"],
  [[350, 20], [ 30, 20], "SpeedUpButton", "速", 0, "SpeedUp"],
  [[380,  0], [120, 20], "TurnInfo", "", 0, NULL],
  [[380, 20], [120, 20], "ClearButton", "クリア", 0, "Clear"],
  [[500,  0], [240, 20], "InitInfo", "", 0, NULL],
  [[500, 20], [ 90, 20], "SetRandomButton", "ランダム", 0, "SetRandom"],
  [[590, 20], [ 50, 20], "SetPresetButton", "既定", 0, "SetPreset"],
  [[640, 20], [ 50, 20], "SelectPresetButton", "選択", 0, "SelectPreset"],
  [[690, 20], [ 50, 20], "InputPresetButton", "入力", 0, "InputPreset"],
  [[740,  0], [240, 20], "RuleInfo", "", 0, NULL],
  [[740, 20], [240, 20], "ChangeRuleButton", "ルール切替", 0, "ChangeRule"]
]

最大表示倍率は１６
最小表示倍率は１

表示起点は[0,0]
表示倍率は１
画面移動率は0.2
ターン数は１
実行状態は「停止」
表示速度は０．０５

現ルールは{
　種類数: 0,
　隣接数: 0,
　TEX: NULL,
　幅: 0,
　高: 0,
　TEX幅: 0,
　TEX高: 0,
　色: {
　　TEX: NULL
　　TEX幅: 0,
　　数: 0
　}
}

REQIDは0
前回タイムスタンプは０
経過時間は０
ステータス更新はオフ
コントロールパネルは{}

シェーダ準備完了はオフ

ルールINDEXは0
配置INDEXは0
初期配置名は空

# 配置中パーツ管理用
配置中位置は空配列
配置中OPTSは{}

# 入力域管理用
ユーザ入力域DIVは空
ユーザ入力域表示中はオフ
登録イベント一覧は空配列
ユーザ入力子領域は{}

#
# メイン処理

ルール一覧準備
配置一覧準備
準備する

# 操作パネルの指定した名称のところに文字を表示する
●(NAMEにLABELを)コントロールラベル描画とは
　CTLはコントロールパネル[NAME]
　もし、CTLでなければ、戻る
　XYはCTL["位置"]
　WHはCTL["サイズ"]
　RはCTL["回転"]
　[XY[0],XY[1],WH[0],WH[1]]に描画クリア
　キャンバス状態保存
　白色に塗り色設定
　[XY[0]+WH[0]/2, XY[1]+WH[1]/2]に描画起点設定
　もし、R≠0ならば、
　　Rに描画回転
　ここまで
　[0,0]にLABELを文字描画
　キャンバス状態復元
ここまで

# 情報表示・操作パネルを配列を元に表示
# 表示の際、辞書型の変数に格納しなおす
●コントロールパネル描画とは
　[0,0,980,40]に描画クリア
　キャンバス状態保存
　コントロールパネルリストを反復する
　　パネルは対象
　　XYはパネル[0]
　　WHはパネル[1]
　　NAMEはパネル[2]
　　LABELはパネル[3]
　　Rはパネル[4]
　　EVTはパネル[5]
　　もし、LABELが空でなければ、
　　　キャンバス状態保存
　　　もし、EVTならば、
　　　　緑色に線色設定
　　　　白色に塗り色設定
　　　　[XY[0]+0.5, XY[1]+0.5, WH[0]-1, WH[1]-1]へ四角描画
　　　　黒色に塗色設定
　　　違えば、
　　　　空に線色設定
　　　　白色に塗り色設定
　　　ここまで
　　　[XY[0]+WH[0]/2, XY[1]+WH[1]/2]に描画起点設定
　　　もし、R≠0ならば、
　　　　Rに描画回転
　　　ここまで
　　　[0,0]にLABELを文字描画
　　　キャンバス状態復元
　　ここまで
　　コントロールは{
　　　ID:NAME,
　　　ラベル:LABEL,
　　　位置:XY,
　　　サイズ:WH,
　　　回転:R,
　　　イベントID:EVT
　　}
　　コントロールパネル[NAME]はコントロール
　ここまで
　キャンバス状態復元
ここまで

# 現在のセル世代の状態を表示する
●現世代描画とは
　FBリスト[表FB]をFB描画する
ここまで

# セル配列を１世代進めて表示する
●世代更新とは
　FBリスト[表FB]からFBリスト[裏FB]へFB更新する

　# FB0とFB1を交換
　表FBは1-表FB
　裏FBは1-表FB

　ターン数はターン数＋１
　現世代描画する
ここまで

●(N)回世代更新とは
　表FBはFBリストの表FBから(N)回FB更新

　# 最後の表FBから裏FBを求める。ターン数を一括して進める
　裏FBは1-表FB
　ターン数はターン数＋N
　現世代描画する
ここまで

# アニメーションフレームのメイン処理
●(タイムスタンプで)アニメーションとは
　もし、実行状態が「停止」でなければ
　　もし、表示速度が０ならば、
　　　世代更新
　　　もし、実行状態が「ステップ」ならば、
　　　　実行状態は「停止」
　　　　ステータス更新はオン
　　　ここまで
　　　経過時間は０
　　違えばもし、表示速度＜０ならば、
　　　(-表示速度)回世代更新
　　　もし、実行状態が「ステップ」ならば、
　　　　実行状態は「停止」
　　　　ステータス更新はオン
　　　ここまで
　　　経過時間は０
　　違えばもし、実行状態が「ステップ」ならば、
　　　世代更新
　　　実行状態は「停止」
　　　ステータス更新はオン
　　　経過時間は０
　　違えばもし、前回タイムスタンプが０でなければ、
　　　経過時間は経過時間＋タイムスタンプ－前回タイムスタンプ
　　　もし、経過時間が(表示速度×１０００)以上ならば、
　　　　更新回数は(経過時間÷(表示速度×１０００))の整数部分
　　　　もし、更新回数＞５ならば、更新回数は５
　　　　(更新回数)回世代更新
　　　　経過時間は経過時間－(更新回数×表示速度×１０００)
　　　ここまで
　　ここまで
　違えば、
　　もし、(配置中パーツ≠NULL)かつ((配置中位置の配列要素数)＞０)ならば、
　　　現世代描画する
　　　配置中位置に配置中パーツを配置中OPTSでパーツ参考描画
　　ここまで
　ここまで
　前回タイムスタンプはタイムスタンプ
　もし、ステータス更新ならば、
　　ステータス表示
　　ステータス更新はオフ
　ここまで
　「{ターン数}世代」を"TurnInfo"にコントロールラベル描画
　REQIDは「アニメーション」を画面更新時実行
ここまで

●ステータス表示とは
　実行状態を"runInfo"にコントロールラベル描画
　「×{表示倍率}」を"zoomInfo"にコントロールラベル描画
　「({表示起点[0]},{表示起点[1]})」を"PositionInfo"にコントロールラベル描画
　「{ワールド["境界ループ"]}」を"LoopInfo"にコントロールラベル描画
　もし、表示速度＝０ならば、
　　「即座」を"SpeedInfo"にコントロールラベル描画
　違えばもし、表示速度＜０ならば、
　　「{0-表示速度}倍速」を"SpeedInfo"にコントロールラベル描画
　違えば、
　　「{表示速度}秒」を"SpeedInfo"にコントロールラベル描画
　ここまで
　「{現ルール["名前"]}」を"RuleInfo"にコントロールラベル描画
　「{初期配置名}」を"InitInfo"にコントロールラベル描画
ここまで

●開始チェックとは
　もし、配置一覧準備完了でなければ、戻る
　もし、ルール一覧準備完了でなければ、戻る
　もし、シェーダ準備完了でなければ、戻る

　開始する
ここまで

●開始とは
　ルール一覧[ルールINDEX]をルール適用する
　# FBリスト[表FB]にランダム初期化する
　# FBリスト[表FB]に配置一覧[1]を配置適用する
　FBリスト[表FB]にランダム初期化する
　初期配置名は「ランダム」
　現世代描画する
　ステータス更新はオン
　描画中キャンバスの"click"に"クリック受付"をDOMイベント追加
　WEBGL用キャンバンスの"click"に"セルクリック受付"をDOMイベント追加
　WEBGL用キャンバンスの"mousemove"に"セルマウス移動受付"をDOMイベント追加

　REQIDは「アニメーション」を画面更新時実行
ここまで

●ルール一覧準備とは
　もし、ルール一覧準備完了でなければ、
　　「rules.json」にAJAX保障送信が成功した時には
　　　対象から「JSON」でAJAX内容取得で戻る
　　ここまで
　　その成功した時には、
　　　ルール一覧は対象
　　　ルール一覧準備完了はオン
　　　開始チェックする
　　ここまで
　ここまで
ここまで

●配置一覧準備とは
　もし、配置一覧準備完了でなければ、
　　「presets.json」にAJAX保障送信が成功した時には
　　　対象から「JSON」でAJAX内容取得で戻る
　　ここまで
　　その成功した時には、
　　　配置一覧は対象
　　　配置一覧準備完了はオン
　　　開始チェックする
　　ここまで
　ここまで
ここまで

●コントロールパネル準備とは
　# コントロールパネル用キャンバスの初期設定
　「16px bold sans-serif」に描画フォント設定
　１に線太さ設定
　描画中コンテキスト["textAlign"]は"center"
　描画中コンテキスト["textBaseline"]は"middle"
　# 初期状態表示
　コントロールパネル描画
ここまで

●準備とは
　ユーザ入力域DIVはユーザ入力域準備する
　最終CTLはコントロールパネルリスト[(コントロールパネルリストの配列要素数)-1]
　描画中キャンバス["width"]は最終CTL[0][0]+最終CTL[1][0]
　描画中キャンバス["height"]は最終CTL[0][1]+最終CTL[1][1]
　描画中キャンバスへ描画開始
　描画中キャンバスの"背景色"に黒色をDOMスタイル設定
　# WEBGL周りの準備をする
　WEBGL用キャンバンスはWEBGL用キャンバス準備
　GLはWEBGL用キャンバンスからGLコンテキスト作成
　シェーダ準備する
　コントロールパネル準備する

　シェーダ準備完了はオン

　開始チェックする
ここまで

●後始末とは
　REQIDを画面更新処理取消
　描画中キャンバスの"click"から"クリック受付"をDOMイベント削除
　WEBGL用キャンバンスの"click"から"セルクリック受付"をDOMイベント削除
　WEBGL用キャンバンスの"mousemove"から"セルマウス移動受付"をDOMイベント削除

　シェーダ始末する
　WEBGL用キャンバス始末する
　ユーザ入力域始末する
ここまで

●クリック受付とは
　EVTはWINDOW["event"]
　要素位置はEVT["target"]の"getBoundingClientRect"を[]でJSメソッド実行
　XはEVT["clientX"]-要素位置["left"]
　YはEVT["clientY"]-要素位置["top"]
　コントロールパネルを反復
　　CTLは対象
　　XYはCTL["位置"]
　　WHはCTL["サイズ"]
　　EVTはCTL["イベントID"]
　　もし、EVTならば、
　　　もし、(X≧XY[0])&&(X≦XY[0]+WH[0])ならば、
　　　　もし、(Y≧XY[1])&&(Y≦XY[1]+WH[1])ならば、
　　　　　EVTでイベント処理
　　　　ここまで
　　　ここまで
　　ここまで
　ここまで
ここまで

●セルクリック受付とは
　EVTはWINDOW["event"]
　要素位置はEVT["target"]の"getBoundingClientRect"を[]でJSメソッド実行
　XはEVT["clientX"]-要素位置["left"]
　YはEVT["clientY"]-要素位置["top"]
　CXは(X÷表示倍率+0.5)の整数部分
　CYは((画面高-Y)÷表示倍率+0.5)の整数部分
　もし、配置中パーツ≠NULLならば、
　　DXは表示起点[0]+CX
　　DYは表示起点[1]+((画面高÷表示倍率+0.5)の整数部分)-CY
　　配置幅は配置中パーツ["幅"]
　　配置高は配置中パーツ["高"]
　　エラー有りはオフ
　　もし、(DX＜ワールド["幅"])かつ(DX+配置幅＞ワールド["幅"])ならば、
　　　#「横位置不正:{DX},{配置幅}」を表示
　　　エラー有りはオン
　　ここまで
　　もし、(DY＜ワールド["高"])かつ(DY+配置高＞ワールド["高"])ならば、
　　　#「縦位置不正:{DY},{配置高}」を表示
　　　エラー有りはオン
　　ここまで
　　もし、エラー有りならば、
　　　もし、(配置中位置の配列要素数)＞０ならば、
　　　　CXは配置中位置[0]
　　　　CYは配置中位置[1]
　　　　エラー有りはオフ
　　　ここまで
　　ここまで
　　もし、エラー有りでなければ、
　　　#「配置:({DX},{DY})-({配置幅},{配置高})」を表示
　　　FBリスト[表FB]の[DX,DY]に配置中パーツを配置中OPTSで配置中パーツ描画
　　　もし、初期配置名が「複合配置」でなければ、
　　　　初期配置名は「複合配置」
　　　　ステータス更新はオン
　　　ここまで
　　　現世代描画する
　　ここまで
　ここまで
ここまで

●セルマウス移動受付とは
　EVTはWINDOW["event"]
　要素位置はEVT["target"]の"getBoundingClientRect"を[]でJSメソッド実行
　XはEVT["clientX"]-要素位置["left"]
　YはEVT["clientY"]-要素位置["top"]
　CXは(X÷表示倍率+0.5)の整数部分
　CYは((画面高-Y)÷表示倍率+0.5)の整数部分
　もし、配置中パーツ≠NULLならば、
　　DXは表示起点[0]+CX
　　DYは表示起点[1]+((画面高÷表示倍率+0.5)の整数部分)-CY
　　配置幅は配置中パーツ["幅"]
　　配置高は配置中パーツ["高"]
　　もし、(DX＜ワールド["幅"])かつ(DX+配置幅＞ワールド["幅"])ならば、
　　　# ワールド境界を跨ぐため座標を記録しない
　　# 違えばもし、(DY-配置高＜０)かつ(DY≧０)ならば、
　　違えばもし、(DY＜ワールド["高"])かつ(DY+配置高＞ワールド["高"])ならば、
　　　# ワールド境界を跨ぐため座標を記録しない
　　違えば、
　　　配置中位置[0]はCX
　　　配置中位置[1]はCY
　　ここまで
　ここまで
ここまで

●(EVTIDで)イベント処理とは
　EVTIDで条件分岐
　　"End"ならば、
　　　もし、実行状態が「停止」ならば
　　　　後始末
　　　　実行状態は「終了」
　　　　ステータス表示
　　　ここまで
　　ここまで
　　"Stop"ならば、
　　　実行状態は「停止」
　　　ステータス更新はオン
　　ここまで
　　"Step"ならば、
　　　もし、ユーザ入力域表示中でなければ、
　　　　実行状態は「ステップ」
　　　　ステータス更新はオン
　　　ここまで
　　ここまで
　　"Start"ならば、
　　　もし、ユーザ入力域表示中でなければ、
　　　　実行状態は「実行中」
　　　　ステータス更新はオン
　　　ここまで
　　ここまで
　　"PosLeft"ならば、
　　　表示起点[0]は表示起点[0]－(画面幅÷表示倍率×画面移動率)の整数部分
　　　表示起点[0]は(表示起点[0]＋ワールド["幅"])%ワールド["幅"]
　　　表示情報更新反映
　　　もし、実行状態が「停止」ならば、現世代描画する。
　　　ステータス更新はオン
　　ここまで
　　"PosRight"ならば、
　　　表示起点[0]は表示起点[0]＋(画面幅÷表示倍率×画面移動率)の整数部分
　　　表示起点[0]は表示起点[0]%ワールド["幅"]
　　　表示情報更新反映
　　　もし、実行状態が「停止」ならば、現世代描画する。
　　　ステータス更新はオン
　　ここまで
　　"PosUp"ならば、
　　　表示起点[1]は表示起点[1]－(画面高÷表示倍率÷２)の整数部分
　　　表示起点[1]は(表示起点[1]＋ワールド["高"])%ワールド["高"]
　　　表示情報更新反映
　　　もし、実行状態が「停止」ならば、現世代描画する。
　　　ステータス更新はオン
　　ここまで
　　"PosDown"ならば、
　　　表示起点[1]は表示起点[1]＋(画面高÷表示倍率×画面移動率)の整数部分
　　　表示起点[1]は表示起点[1]%ワールド["高"]
　　　表示情報更新反映
　　　もし、実行状態が「停止」ならば、現世代描画する。
　　　ステータス更新はオン
　　ここまで
　　"PosHome"ならば、
　　　表示起点[0]は(ワールド["幅"]÷２－画面幅÷表示倍率÷２)の整数部分
　　　表示起点[1]は(ワールド["高"]÷２－画面高÷表示倍率÷２)の整数部分
　　　表示情報更新反映
　　　もし、実行状態が「停止」ならば、現世代描画する。
　　　ステータス更新はオン
　　ここまで
　　"ChangeLoop"ならば、
　　　もし、ワールド["境界ループ"]＝「LOOP」ならば、
　　　　ワールド["境界ループ"]は「CLIP」
　　　違えば、
　　　　ワールド["境界ループ"]は「LOOP」
　　　ここまで
　　　ステータス更新はオン
　　ここまで
　　"ZoomIn"ならば、
　　　もし、表示倍率＜最大表示倍率ならば、
　　　　表示起点[0]は表示起点[0]＋(画面幅÷表示倍率÷２)の整数部分
　　　　表示起点[1]は表示起点[1]＋(画面高÷表示倍率÷２)の整数部分
　　　　表示倍率は表示倍率×２
　　　　表示起点[0]は表示起点[0]－(画面幅÷表示倍率÷２＋０．５)の整数部分
　　　　表示起点[1]は表示起点[1]－(画面高÷表示倍率÷２＋０．５)の整数部分
　　　　表示起点[0]は(表示起点[0]＋ワールド["幅"])%ワールド["幅"]
　　　　表示起点[1]は(表示起点[1]＋ワールド["高"])%ワールド["高"]
　　　　表示情報更新反映
　　　　もし、実行状態が「停止」ならば、現世代描画する。
　　　　ステータス更新はオン
　　　ここまで
　　ここまで
　　"ZoomOut"ならば、
　　　もし、表示倍率＞最小表示倍率ならば、
　　　　表示起点[0]は表示起点[0]＋(画面幅÷表示倍率÷２＋０．５)の整数部分
　　　　表示起点[1]は表示起点[1]＋(画面高÷表示倍率÷２＋０．５)の整数部分
　　　　表示倍率は表示倍率÷２
　　　　表示起点[0]は表示起点[0]－(画面幅÷表示倍率÷２)の整数部分
　　　　表示起点[1]は表示起点[1]－(画面高÷表示倍率÷２)の整数部分
　　　　表示起点[0]は(表示起点[0]＋ワールド["幅"])%ワールド["幅"]
　　　　表示起点[1]は(表示起点[1]＋ワールド["高"])%ワールド["高"]
　　　　表示情報更新反映
　　　　もし、実行状態が「停止」ならば、現世代描画する。
　　　　ステータス更新はオン
　　　ここまで
　　ここまで
　　"SpeedDown"ならば、
　　　表示速度で条件分岐
　　　　(-50)ならば、表示速度は(-30)。ここまで。
　　　　(-30)ならば、表示速度は(-20)。ここまで。
　　　　(-20)ならば、表示速度は(-10)。ここまで。
　　　　(-10)ならば、表示速度は(-5)。ここまで。
　　　　(-5)ならば、表示速度は(-3)。ここまで。
　　　　(-3)ならば、表示速度は(-2)。ここまで。
　　　　(-2)ならば、表示速度は0。ここまで。
　　　　0ならば、表示速度は0.02。ここまで。
　　　　0.02ならば、表示速度は0.05。ここまで。
　　　　0.05ならば、表示速度は0.1。ここまで。
　　　　0.1ならば、表示速度は0.2。ここまで。
　　　　0.2ならば、表示速度は0.5。ここまで。
　　　　0.5ならば、表示速度は1。ここまで。
　　　　1ならば、表示速度は3。ここまで。
　　　　3ならば、表示速度は5。ここまで。
　　　　5ならば、表示速度は10。ここまで。
　　　ここまで
　　　ステータス更新はオン
　　ここまで
　　"SpeedUp"ならば、
　　　表示速度で条件分岐
　　　　(-30)ならば、表示速度は(-50)。ここまで。
　　　　(-20)ならば、表示速度は(-30)。ここまで。
　　　　(-10)ならば、表示速度は(-20)。ここまで。
　　　　(-5)ならば、表示速度は(-10)。ここまで。
　　　　(-3)ならば、表示速度は(-5)。ここまで。
　　　　(-2)ならば、表示速度は(-3)。ここまで。
　　　　0ならば、表示速度は(-2)。ここまで。
　　　　0.02ならば、表示速度は0。ここまで。
　　　　0.05ならば、表示速度は0.02。ここまで。
　　　　0.1ならば、表示速度は0.05。ここまで。
　　　　0.2ならば、表示速度は0.1。ここまで。
　　　　0.5ならば、表示速度は0.2。ここまで。
　　　　1ならば、表示速度は0.5。ここまで。
　　　　3ならば、表示速度は1。ここまで。
　　　　5ならば、表示速度は3。ここまで。
　　　　10ならば、表示速度は5。ここまで。
　　　ここまで
　　　ステータス更新はオン
　　ここまで
　　"Clear"ならば、
　　　もし、実行状態が「停止」ならば
　　　　FBリスト[表FB]に空初期化する
　　　　現世代描画する
　　　　ターン数は１
　　　　ステータス更新はオン
　　　ここまで
　　ここまで
　　"SetRandom"ならば、
　　　もし、実行状態が「停止」ならば
　　　　FBリスト[表FB]にランダム初期化する
　　　　現世代描画する
　　　　ターン数は１
　　　　ステータス更新はオン
　　　ここまで
　　ここまで
　　"SetPreset"ならば、
　　　もし、実行状態が「停止」ならば
　　　　初期INDEXは配置INDEX
　　　　配置更新はオフ
　　　　オンの間
　　　　　配置INDEXは配置INDEX+1
　　　　　もし、配置INDEX≧(配置一覧の配列要素数)ならば、
　　　　　　配置INDEXは0
　　　　　ここまで
　　　　　もし、配置一覧[配置INDEX]["RULE"]＝現ルール["名前"]ならば、
　　　　　　エラー監視
　　　　　　　FBリスト[表FB]に配置一覧[配置INDEX]を配置適用する
　　　　　　　配置更新はオン
　　　　　　　抜ける
　　　　　　エラーならば
　　　　　　　# エラーなら次のエントリへ
　　　　　　ここまで
　　　　　ここまで
　　　　　もし、初期INDEX＝配置INDEXならば、
　　　　　　「ルールに合う既定の配置セットは有りませんでした」を言う
　　　　　　抜ける
　　　　　ここまで
　　　　ここまで
　　　　もし、配置更新ならば、
　　　　　現世代描画する
　　　　　ターン数は１
　　　　　ステータス更新はオン
　　　　ここまで
　　　ここまで
　　ここまで
　　"SelectPreset"ならば、
　　　もし、(実行状態＝「停止」)かつ(ユーザ入力域表示中＝オフ)ならば
　　　　選択肢は空配列
　　　　(配置一覧の配列要素数)回繰り返す
　　　　　IDXは回数-1
　　　　　もし、配置一覧[IDX]["RULE"]＝現ルール["名前"]ならば、
　　　　　　NMは配置一覧[IDX]["NAME"]
　　　　　　選択肢に{INDEX: IDX, NAME: NM }を配列追加
　　　　　ここまで
　　　　ここまで
　　　　もし、(選択肢の配列要素数)＝０でなければ、
　　　　　SELは「#preset_select」のDOM要素取得
　　　　　SEL["innerHTML"]は空
　　　　　選択肢を反復する
　　　　　　OPTは「OPTION」をDOM要素作成
　　　　　　OPT["innerText"]は対象["NAME"]
　　　　　　OPT["value"]は対象["INDEX"]
　　　　　　SELにOPTをDOM子要素追加
　　　　　ここまで
　　　　　配置中OPTS["反転"]はオフ
　　　　　配置中OPTS["回転"]は0
　　　　　SELはSEL["parentNode"]の「select.hanten」をDOM子要素取得
　　　　　SEL["selectedIndex"]は0
　　　　　SELはSEL["parentNode"]の「select.kaiten」をDOM子要素取得
　　　　　SEL["selectedIndex"]は0
　　　　　ユーザ入力モードは「配置選択」
　　　　　「選択配置」をユーザ入力子領域開く
　　　　ここまで
　　　ここまで
　　ここまで
　　"InputPreset"ならば、
　　　もし、(実行状態＝「停止」)かつ(ユーザ入力域表示中＝オフ)ならば
　　　　SELは「#preset_text」のDOM要素取得
　　　　配置中OPTS["反転"]はオフ
　　　　配置中OPTS["回転"]は0
　　　　SELはSEL["parentNode"]の「select.hanten」をDOM子要素取得
　　　　SEL["selectedIndex"]は0
　　　　SELはSEL["parentNode"]の「select.kaiten」をDOM子要素取得
　　　　SEL["selectedIndex"]は0
　　　　ユーザ入力モードは「配置入力」
　　　　「入力配置」をユーザ入力子領域開く
　　　ここまで
　　ここまで
　　"ChangeRule"ならば、
　　　もし、(実行状態＝「停止」)かつ(ユーザ入力域表示中＝オフ)ならば
　　　　もし、(ルール一覧の配列要素数)＞１ならば、
　　　　　ルールINDEXはルールINDEX+1
　　　　　もし、ルールINDEX≧(ルール一覧の配列要素数)ならば、
　　　　　　ルールINDEXは0
　　　　　ここまで
　　　　　ルール一覧[ルールINDEX]をルール適用する
　　　　　FBリスト[表FB]に空初期化する
　　　　　現世代描画する
　　　　　ターン数は１
　　　　　ステータス更新はオン
　　　　ここまで
　　　ここまで
　　ここまで
　ここまで
ここまで

# 入力域系定義命令

●ユーザ入力域配置域準備とは
　情報は{
　　NAME: "入力配置",
　　ID: "ui_preset_input",
　　ELEMENT: NULL,
　　EVENT: []
　}
　elemは「P」をDOM要素作成
　elem["id"]は情報["ID"]
　elem["innerHTML"]は『配置するデータを入力してください。単純に状態の数字を四角形に並べた形式とRLE形式を取り込めます。<br>
<button class="clear">クリア</button>
<button class="presetOne" alt="クリア後１つ配置して欄を閉じる">単独配置</button>
<button class="presetMulti" alt="欄を閉じるまでクリックした位置毎に配置">連続配置</button>
<button class="close">閉じる</button><br>
<span class="set_option">
左右反転
<select class="hanten"><option value="0" selected>せず</option><option value="1">して</option></select>
時計回りに
<select class="kaiten"><option value="0" selected>0</option><option value="90">90</option><option value="180">180</option><option value="270">270</option></select>
度回転する
</span><br>
<textarea id="preset_text" rows="10" cols="80"></textarea>』
　情報["ELEMENT"]はelem

　callbackは変数内には
　　TEXTは「#preset_text」のDOM要素取得
　　TEXT["value"]は空
　ここまで
　evtは{
　　query:"button.clear",
　　event:"click",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　callbackは変数内には
　　EVTはWINDOW["event"]
　　SELはEVT["target"]
　　もし、SEL["selectedIndex"]≧０ならば、
　　　もし、SEL["options"][SEL["selectedIndex"]]["value"]≠０ならば、
　　　　配置中OPTS["反転"]はオン
　　　違えば、
　　　　配置中OPTS["反転"]はオフ
　　　ここまで
　　ここまで
　ここまで
　evtは{
　　query:"select.hanten",
　　event:"change",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　callbackは変数内には
　　EVTはWINDOW["event"]
　　SELはEVT["target"]
　　もし、SEL["selectedIndex"]≧０ならば、
　　　配置中OPTS["回転"]はSEL["options"][SEL["selectedIndex"]]["value"]-0
　　ここまで
　ここまで
　evtは{
　　query:"select.kaiten",
　　event:"change",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　callbackは変数内には
　　もし、配置中パーツ≠NULLならば、
　　　配置中パーツを配置パーツ破棄
　　　配置中パーツはNULL
　　　現世代描画する
　　ここまで
　　ユーザ入力域閉じる
　ここまで
　evtは{
　　query:"button.close",
　　event:"click",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　callbackは変数内には
　　もし、配置中パーツ≠NULLならば、
　　　配置中パーツを配置パーツ破棄
　　　配置中パーツはNULL
　　　現世代描画する
　　ここまで
　　TEXTは「#preset_text」のDOM要素取得
　　エラー表示済みはオフ
　　エラー監視
　　　配置中パーツはTEXT["value"]を配置パーツ作成
　　　配置幅は配置中パーツ["高"]
　　　配置高は配置中パーツ["幅"]
　　　回転は[0,90,180,270]
　　　もし、(配置中パーツ["幅"]＞ワールド["高"])または(配置中パーツ["高"]＞ワールド["幅"])ならば、
　　　　回転は[0,180]
　　　ここまで
　　　もし、(配置中パーツ["幅"]＞ワールド["幅"])または(配置中パーツ["高"]＞ワールド["高"])ならば、
　　　　回転は[90,270]
　　　ここまで
　　　もし、回転[0]＝90または回転[0]＝270ならば、
　　　　配置幅は配置中パーツ["高"]
　　　　配置高は配置中パーツ["幅"]
　　　ここまで
　　　配置中位置[0]は((画面幅÷表示倍率－配置幅)÷２)の整数部分
　　　配置中位置[1]は((画面高÷表示倍率＋配置高)÷２)の整数部分
　　　配置中OPTS["反転"]はオフ
　　　配置中OPTS["回転"]は回転[0]
　　　SELは「#preset_text」のDOM要素取得
　　　SELはSEL["parentNode"]の「select.hanten」をDOM子要素取得
　　　SEL["selectedIndex"]は0
　　　SELはSEL["parentNode"]の「select.kaiten」をDOM子要素取得
　　　SEL["innerHTML"]は空
　　　回転を反復する
　　　　OPTは「OPTION」をDOM要素作成
　　　　OPT["innerText"]は対象
　　　　OPT["value"]は対象
　　　　SELにOPTをDOM子要素追加
　　　ここまで
　　　SEL["selectedIndex"]は0
　　エラーならば
　　　もし、エラーメッセージが「ユーザによる配置取り消し」でなければ、
　　　　もし、エラー表示済みでなければ、
　　　　　エラー表示済みはオン
　　　　　エラーメッセージを言う
　　　　ここまで
　　　ここまで
　　ここまで
　ここまで
　evtは{
　　query:"button.presetMulti",
　　event:"click",
　　callback:callback
　}

　情報["EVENT"]にevtを配列追加する
　callbackは変数内には
　　もし、配置中パーツ≠NULLならば、
　　　配置中パーツを配置パーツ破棄
　　　配置中パーツはNULL
　　　現世代描画する
　　ここまで
　　TEXTは「#preset_text」のDOM要素取得
　　エラー表示済みはオフ
　　エラー監視
　　　パーツはTEXT["value"]を配置パーツ作成
　　　FBリスト[表FB]にパーツをパーツ全体描画
　　　初期配置名は「ユーザ入力」
　　　現世代描画する
　　　ターン数は１
　　　ステータス更新はオン
　　　ユーザ入力域閉じる
　　エラーならば
　　　もし、エラーメッセージが「ユーザによる配置取り消し」でなければ、
　　　　もし、エラー表示済みでなければ、
　　　　　エラー表示済みはオン
　　　　　エラーメッセージを言う
　　　　ここまで
　　　ここまで
　　ここまで
　ここまで
　evtは{
　　query:"button.presetOne",
　　event:"click",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　情報で戻る
ここまで

●ユーザ入力域配置選択域準備とは
　情報は{
　　NAME: "選択配置",
　　ID: "ui_preset_select",
　　ELEMENT: NULL,
　　EVENT: []
　}
　elemは「P」をDOM要素作成
　elem["id"]は情報["ID"]
　elem["innerHTML"]は『配置するデータを選んでください。<br>
<button class="presetOne" alt="クリア後１つ配置して欄を閉じる">単独配置</button>
<button class="presetMulti" alt="欄を閉じるまでクリックした位置毎に配置">連続配置</button>
<button class="close">閉じる</button><br>
<select id="preset_select"></select><br>
<span class="set_option">
左右反転
<select class="hanten"><option value="0" selected>せず</option><option value="1">して</option></select>
時計回りに
<select class="kaiten"><option value="0" selected>0</option><option value="90">90</option><option value="180">180</option><option value="270">270</option></select>
度回転する
</span>』
　情報["ELEMENT"]はelem

　callbackは変数内には
　　もし、配置中パーツ≠NULLならば、
　　　配置中パーツを配置パーツ破棄
　　　配置中パーツはNULL
　　　現世代描画する
　　ここまで
　　ユーザ入力域閉じる
　ここまで
　evtは{
　　query:"button.close",
　　event:"click",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　callbackは変数内には
　　EVTはWINDOW["event"]
　　SELはEVT["target"]
　　もし、SEL["selectedIndex"]≧０ならば、
　　　もし、SEL["options"][SEL["selectedIndex"]]["value"]≠０ならば、
　　　　配置中OPTS["反転"]はオン
　　　違えば、
　　　　配置中OPTS["反転"]はオフ
　　　ここまで
　　ここまで
　ここまで
　evtは{
　　query:"select.hanten",
　　event:"change",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　callbackは変数内には
　　EVTはWINDOW["event"]
　　SELはEVT["target"]
　　もし、SEL["selectedIndex"]≧０ならば、
　　　配置中OPTS["回転"]はSEL["options"][SEL["selectedIndex"]]["value"]
　　ここまで
　ここまで
　evtは{
　　query:"select.kaiten",
　　event:"change",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　callbackは変数内には
　　もし、配置中パーツ≠NULLならば、
　　　配置中パーツを配置パーツ破棄
　　　配置中パーツはNULL
　　　現世代描画する
　　ここまで
　　SELは「#preset_select」のDOM要素取得
　　エラー表示済みはオフ
　　エラー監視
　　　OPTはSEL["options"][SEL["selectedIndex"]]
　　　IDXはOPT["value"]
　　　配置情報は配置一覧[IDX]
　　　DATAは配置情報["DATA"]
　　　配置中パーツはDATAを配置パーツ作成
　　　配置幅は配置中パーツ["高"]
　　　配置高は配置中パーツ["幅"]
　　　回転は[0,90,180,270]
　　　もし、(配置中パーツ["幅"]＞ワールド["高"])または(配置中パーツ["高"]＞ワールド["幅"])ならば、
　　　　回転は[0,180]
　　　ここまで
　　　もし、(配置中パーツ["幅"]＞ワールド["幅"])または(配置中パーツ["高"]＞ワールド["高"])ならば、
　　　　回転は[90,270]
　　　ここまで
　　　もし、回転[0]＝90または回転[0]＝270ならば、
　　　　配置幅は配置中パーツ["高"]
　　　　配置高は配置中パーツ["幅"]
　　　ここまで
　　　配置中位置[0]は((画面幅÷表示倍率－配置幅)÷２)の整数部分
　　　配置中位置[1]は((画面高÷表示倍率＋配置高)÷２)の整数部分
　　　配置中OPTS["反転"]はオフ
　　　配置中OPTS["回転"]は回転[0]
　　　SELは「#preset_select」のDOM要素取得
　　　SELはSEL["parentNode"]の「select.hanten」をDOM子要素取得
　　　SEL["selectedIndex"]は0
　　　SELはSEL["parentNode"]の「select.kaiten」をDOM子要素取得
　　　SEL["innerHTML"]は空
　　　回転を反復する
　　　　OPTは「OPTION」をDOM要素作成
　　　　OPT["innerText"]は対象
　　　　OPT["value"]は対象
　　　　SELにOPTをDOM子要素追加
　　　ここまで
　　　SEL["selectedIndex"]は0
　　エラーならば
　　　もし、エラーメッセージが「ユーザによる配置取り消し」でなければ、
　　　　もし、エラー表示済みでなければ、
　　　　　エラー表示済みはオン
　　　　　エラーメッセージを言う
　　　　ここまで
　　　ここまで
　　ここまで
　ここまで
　evtは{
　　query:"button.presetMulti",
　　event:"click",
　　callback:callback
　}

　情報["EVENT"]にevtを配列追加する
　callbackは変数内には
　　もし、配置中パーツ≠NULLならば、
　　　配置中パーツを配置パーツ破棄
　　　配置中パーツはNULL
　　　現世代描画する
　　ここまで
　　SELは「#preset_select」のDOM要素取得
　　エラー表示済みはオフ
　　エラー監視
　　　OPTはSEL["options"][SEL["selectedIndex"]]
　　　IDXはOPT["value"]
　　　配置情報は配置一覧[IDX]
　　　DATAは配置情報["DATA"]
　　　パーツはDATAを配置パーツ作成
　　　FBリスト[表FB]にパーツをパーツ全体描画
　　　初期配置名は配置情報["NAME"]
　　　現世代描画する
　　　ターン数は１
　　　ステータス更新はオン
　　　ユーザ入力域閉じる
　　エラーならば
　　　もし、エラーメッセージが「ユーザによる配置取り消し」でなければ、
　　　　もし、エラー表示済みでなければ、
　　　　　エラー表示済みはオン
　　　　　エラーメッセージを言う
　　　　ここまで
　　　ここまで
　　ここまで
　ここまで
　evtは{
　　query:"button.presetOne",
　　event:"click",
　　callback:callback
　}
　情報["EVENT"]にevtを配列追加する

　情報で戻る
ここまで

# 入力域系補助関数

●(入力域名を)ユーザ入力子領域開くとは
　もし、ユーザ入力域表示中ならば、
　　戻る
　ここまで
　DIVは「#userinput_div」をDOM要素取得
　もし、DIVならば、
　　有るはオフ
　　ユーザ入力子領域を反復する
　　　Uは「#{対象}」をDOM要素取得
　　　もし、(U)かつ(U≠NULL)ならば、
　　　　もし、対象キー＝入力域名ならば、
　　　　　U["style"]["display"]は「block」
　　　　　有るはオン
　　　　違えば、
　　　　　U["style"]["display"]は「none」
　　　　ここまで
　　　ここまで
　　ここまで
　　もし、有るならば、
　　　DIV["style"]["display"]は「block」
　　　ユーザ入力域表示中はオン
　　ここまで
　ここまで
ここまで

●ユーザ入力域閉じるとは
　ユーザ入力子領域を反復する
　　Uは「#{対象}」をDOM要素取得
　　もし、(U)かつ(U≠NULL)ならば、
　　　U["style"]["display"]は「none」
　　ここまで
　ここまで
　DIVは「#userinput_div」をDOM要素取得
　もし、DIVならば、
　　DIV["style"]["display"]は「none」
　　ユーザ入力域表示中はオフ
　ここまで
ここまで

●(DIVにINFOを)ユーザ入力子領域追加とは
　ユーザ入力子領域[INFO["NAME"]]はINFO["ID"]
　UはINFO["ELEMENT"]
　U["id"]はINFO["ID"]
　DIVにUをDOM子要素追加
　INFO["EVENT"]を反復する
　　elemはUの対象["query"]をDOM子要素取得
　　elemの対象["event"]に対象["callback"]をDOMイベント追加
　　登録イベント一覧に{
　　　dom: elem,
　　　event: 対象["event"],
　　　callback: 対象["callback"]
　　}を配列追加
　ここまで
ここまで

●ユーザ入力域準備とは
　ユーザ入力域始末する
　DIVは「DIV」のDOM要素作成
　情報はユーザ入力域配置域準備
　DIVに情報をユーザ入力子領域追加
　情報はユーザ入力域配置選択域準備
　DIVに情報をユーザ入力子領域追加
　DIV["id"]は「userinput_div」
　DIV["style"]["display"]は「none」
　描画中キャンバス["parentNode"]にDIVをDOM子要素追加
　ユーザ入力域表示中はオフ
　DIVで戻る
ここまで

●ユーザ入力域始末とは
　登録イベント一覧を反復する
　　対象["dom"]の対象["event"]から対象["callback"]をDOMイベント削除する
　ここまで
　登録イベント一覧は空配列
　DIVは「#userinput_div」をDOM要素取得
　もし、DIVならば、
　　DIV["parentNode"]からDIVをDOM子要素削除
　ここまで
ここまで

#
#
#
●WEBGL用キャンバス準備とは
　WEBGL用キャンバス始末する
　CANVASは「CANVAS」のDOM要素作成
　CANVAS["width"]は画面幅
　CANVAS["height"]は画面高
　CANVAS["id"]は「webgl_cv」
　描画中キャンバス["parentNode"]にCANVASをDOM子要素追加
　CANVASで戻る
ここまで

●WEBGL用キャンバス始末とは
　CANVASは「#webgl_cv」をDOM要素取得
　もし、CANVASならば、
　　CANVAS["parentNode"]からCANVASをDOM子要素削除
　ここまで
ここまで

●シェーダ準備とは
　# データの保存に必要なテクスチャのサイズを求める
　基本底数は２でワールド["幅"]のLOGNを切り上げ
　ワールド["TEX幅"]は２の(基本底数)乗
　第二底数は２でワールド["高"]のLOGNを切り上げ
　ワールド["TEX高"]は２の(第二底数)乗
　
　# WEBGLの拡張機能のチェックと限界数の表示を行う
　VATTR数は"MAX_VERTEX_ATTRIBS"のGLパラメータ取得
　「利用可能なV属性数={VATTR数}」を表示

　TEXSIZEMAXは"MAX_TEXTURE_SIZE"のGLパラメータ取得
　「最大TEXサイズ={TEXSIZEMAX}」を表示

　頂点シェーダは『attribute vec2 aPos;
    attribute vec2 aTexCoord;
    varying vec2 vTexCoord;
    void main() {
      vTexCoord = aTexCoord;
      gl_Position = vec4(aPos, 0.0, 1.0);
    }』から"頂点"のGLシェーダ作成

　更新シェーダは『precision highp float;
    uniform sampler2D uTex;
    uniform sampler2D uTexRule;
    uniform vec2 uTexSize;
    uniform vec2 uTexRuleSize;
    uniform int uNstate;
    uniform int uNeighbourhood;
    uniform int uWorldLoop;
    uniform vec2 uWorldSize;
    varying vec2 vTexCoord;
    int f2state(float a) {
      return int(floor(a * 255.0 + 0.5));
    }
    float state2f(int c) {
      return float(c) / 255.0;
    }
    vec4 c2v(int c) {
      return vec4(state2f(c), 0.0, 0.0, 1.0);
    }
    int get(float dx, float dy, vec2 scale) {
      vec2 pos = (uWorldLoop==0)?gl_FragCoord.xy+vec2(dx,dy):mod(gl_FragCoord.xy+vec2(dx,dy)+uWorldSize,uWorldSize);
      float r = any(bvec4(lessThan(pos,vec2(0.0,0.0)),greaterThanEqual(pos,uWorldSize)))?0.0:texture2D(uTex, pos * scale).r;
      return f2state(r);
    }
    int pick(int i, int o) {
      vec2 scale = 1.0 / uTexRuleSize;
      vec2 halfScale = scale * 0.5;
      float f = floor(float(i) / 4.0);
      int b = int(mod(float(i), 4.0));
      vec2 pos = vec2(mod(f, uTexRuleSize.x), floor(f / uTexRuleSize.x));
      vec4 rgba = texture2D(uTexRule, pos * scale + halfScale);
      float a = ( b == 0 ) ? rgba.r : ( ( b == 1 ) ? rgba.g : ( ( b == 2 ) ? rgba.b : rgba.a ) );
      int c = ( a == 1.0 ) ? o : f2state(a);
      return c;
    }
    void main() {
      vec2 scale = 1.0 / uTexSize;
      int cur = get(0.0, 0.0, scale);
      int i = cur;
      i = i * uNstate + get( 0.0,-1.0, scale);
      i = uNeighbourhood == 9 ? i * uNstate + get( 1.0,-1.0, scale) : i;
      i = i * uNstate + get( 1.0, 0.0, scale);
      i = uNeighbourhood == 9 ? i * uNstate + get( 1.0, 1.0, scale) : i;
      i = i * uNstate + get( 0.0, 1.0, scale);
      i = uNeighbourhood == 9 ? i * uNstate + get(-1.0, 1.0, scale) : i;
      i = i * uNstate + get(-1.0, 0.0, scale);
      i = uNeighbourhood == 9 ? i * uNstate + get(-1.0,-1.0, scale) : i;
      gl_FragColor = c2v(pick(i, cur));
    }』から"フラグメント"のGLシェーダ作成

　表示シェーダは『precision highp float;
    uniform sampler2D uTex;
    uniform sampler2D uTexColor;
    uniform int uNstate;
    uniform float uTexColorWidth;
    uniform float uAlpha;
    varying vec2 vTexCoord;
    int f2state(float a) {
      return int(floor(a * 255.0 + 0.5));
    }
    void main() {
      int c = f2state(texture2D(uTex, vTexCoord).r);
      float scale = 1.0 / uTexColorWidth;
      float halfScale = scale * 0.5;
      gl_FragColor = vec4(texture2D(uTexColor, vec2(float(c) * scale + halfScale, 0.5)).rgb, uAlpha);
    }』から"フラグメント"のGLシェーダ作成

　初期化シェーダは『precision highp float;
    uniform sampler2D uTex;
    varying vec2 vTexCoord;
    void main() {
      gl_FragColor = texture2D(uTex, vTexCoord);
    }』から"フラグメント"のGLシェーダ作成

　もし、頂点シェーダ＝NULLまたは、表示シェーダ＝NULLまたは、更新シェーダ=NULLまたは、初期化シェーダ＝NULLならば、
　　「シェーダのコンパイルに失敗しました」でエラー発生
　ここまで

　PGMは頂点シェーダと更新シェーダからGLプログラム作成
　更新プログラムは{
　　PROGRAM: PGM,
　　PARAM: {
　　　頂点: { TYPE: "ATTR", NAME: 「aPos」 },
　　　UV: { TYPE: "ATTR", NAME: 「aTexCoord」 },
　　　テクスチャ: { TYPE: "1i", NAME: 「uTex」 },
　　　テクスチャサイズ: { TYPE: "2fv", NAME: 「uTexSize」 },
　　　ルールテクスチャ: { TYPE: "1i", NAME: 「uTexRule」 },
　　　ルールテクスチャサイズ: { TYPE: "2fv", NAME: 「uTexRuleSize」 },
　　　ワールドサイズ: { TYPE: "2fv", NAME: 「uWorldSize」 },
　　　種類数: { TYPE: "1i", NAME: 「uNstate」 },
　　　隣接数: { TYPE: "1i", NAME: 「uNeighbourhood」 },
　　　ループ: { TYPE: "1i", NAME: 「uWorldLoop」 }
　　}
　}
　更新プログラムのパラメータロケーション情報更新

　PGMは頂点シェーダと表示シェーダからGLプログラム作成
　表示プログラムは{
　　PROGRAM: PGM,
　　PARAM: {
　　　頂点: { TYPE: "ATTR", NAME: 「aPos」 },
　　　UV: { TYPE: "ATTR", NAME: 「aTexCoord」 },
　　　テクスチャ: { TYPE: "1i", NAME: 「uTex」 },
　　　色テクスチャ: { TYPE: "1i", NAME: 「uTexColor」 },
　　　色テクスチャ幅: { TYPE: "1f", NAME: 「uTexColorWidth」 },
　　　アルファ値: { TYPE: "1f", NAME: 「uAlpha」 },
　　　種類数: { TYPE: "1i", NAME: 「uNstate」 }
　　}
　}
　表示プログラムのパラメータロケーション情報更新

　PGMは頂点シェーダと初期化シェーダからGLプログラム作成
　初期化プログラムは{
　　PROGRAM: PGM,
　　PARAM: {
　　　頂点: { TYPE: "ATTR", NAME: 「aPos」 },
　　　UV: { TYPE: "ATTR", NAME: 「aTexCoord」 },
　　　テクスチャ: { TYPE: "1i", NAME: 「uTex」 }
　　}
　}
　初期化プログラムのパラメータロケーション情報更新

　# テクスチャ全体を描画対象全体に対してマッピングする
　# 主にテクスチャからテクスチャへの処理に利用
　# viewportは描画先のテクスチャの全体を想定
　# 上限反転無し
　# X,Y,U,Vの順
　全体頂点情報リストは[
    -1.0,  1.0, 0.0, 1.0,
     1.0,  1.0, 1.0, 1.0,
    -1.0, -1.0, 0.0, 0.0,
     1.0, -1.0, 1.0, 0.0
  ]
　全体頂点情報バッファは{
　　BUF: 全体頂点情報リストからGL静的配列バッファ作成,
　　STRIDE: 16,
　　NUM: 4,
　　TYPE: "TRIANGLE_STRIP",
　　PARAM: {
　　　頂点: { OFFSET: 0, NUM: 2 },
　　　UV: { OFFSET: 8, NUM: 2 }
　　}
　}

　# テクスチャのうちワールド全体を描画対象全体に対してマッピングする
　# 主に、世代更新時のワールド部分全体の処理に利用
　# viewportは出力先のフレームバッファのテクスチャのサイズを想定
　# 上限反転無し
　Xはワールド["幅"]/ワールド["TEX幅"]*2-1
　Yはワールド["高"]/ワールド["TEX高"]*2-1
　Uはワールド["幅"]/ワールド["TEX幅"]
　Vはワールド["高"]/ワールド["TEX高"]
　# X,Y,U,Vの順
　更新頂点情報リストは[
    -1.0,    Y, 0.0,   V,
       X,    Y,   U,   V,
    -1.0, -1.0, 0.0, 0.0,
       X, -1.0,   U, 0.0
  ]
　更新頂点情報バッファは{
　　BUF: 更新頂点情報リストからGL静的配列バッファ作成,
　　STRIDE: 16,
　　NUM: 4,
　　TYPE: "TRIANGLE_STRIP",
　　PARAM: {
　　　頂点: { OFFSET: 0, NUM: 2 },
　　　UV: { OFFSET: 8, NUM: 2 }
　　}
　}

　# 頂点情報の枠数の確保のみを目的にしたダミーデータ
　# TRIANGLESで４角形を４つ分確保する。
　ダミー頂点情報リストは[
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0,
     0.0, 0.0, 0.0, 0.0
  ]

　# 画面への描画用の頂点情報
　# ダミーのデータで必要数分(6*4*4)の確保のみ行う。
　# viewportは画面(canvas)のサイズを想定
　# 上限反転する
　表示頂点情報バッファは{
　　BUF: ダミー頂点情報リストからGL静的配列バッファ作成,
　　STRIDE: 16,
　　NUM: 0,
　　TYPE: "TRIANGLES",
　　PARAM: {
　　　頂点: { OFFSET: 0, NUM: 2 },
　　　UV: { OFFSET: 8, NUM: 2 }
　　}
　}

　# パーツの部分配置の際と、パーツの参考描画の際に使用する
　# ダミーのデータで必要数分(6*4*4)の確保のみ行う。
　# viewportは描画先のテクスチャの全体を想定
　# 上下反転は用途に因る（表示は反転有り、配置は反転無し）
　部分頂点情報バッファは{
　　BUF: ダミー頂点情報リストからGL静的配列バッファ作成,
　　STRIDE: 16,
　　NUM: 0,
　　TYPE: "TRIANGLES",
　　PARAM: {
　　　頂点: { OFFSET: 0, NUM: 2 },
　　　UV: { OFFSET: 8, NUM: 2 }
　　}
　}

　表示情報更新反映

　0をGLテクスチャ枠指定

　２回繰り返す
　　TEXはNULLから[ワールド["TEX幅"],ワールド["TEX高"]]のGLテクスチャ作成
　　FBリスト[回数-1]は{
　　　FB: ({COLOR: TEX}のGLフレームバッファ作成),
　　　TEX: TEX,
　　　TEX幅: ワールド["TEX幅"],
　　　TEX高: ワールド["TEX高"],
　　　幅: ワールド["幅"],
　　　高: ワールド["高"]
　　}
　ここまで
ここまで

●シェーダ始末とは
　0をGLテクスチャ枠指定
　NULLをGLテクスチャ設定
　1をGLテクスチャ枠指定
　NULLをGLテクスチャ設定
　# このプログラムでは最大でも0-1までしか使用しないので以降は削除しない

　現ルールをルール破棄
　もし、空初期化用テクスチャ≠NULLならば
　　空初期化用テクスチャをGLテクスチャ削除
　ここまで
　もし、配置中パーツ≠NULLならば
　　配置中パーツを配置パーツ破棄
　ここまで

　NULLをGLバッファ設定
　全体頂点情報バッファ["BUF"]をGLバッファ削除
　表示頂点情報バッファ["BUF"]をGLバッファ削除
　更新頂点情報バッファ["BUF"]をGLバッファ削除
　部分頂点情報バッファ["BUF"]をGLバッファ削除

　NULLをGLプログラム使用
　更新プログラム["PROGRAM"]をGLプログラム削除
　表示プログラム["PROGRAM"]をGLプログラム削除
　初期化プログラム["PROGRAM"]をGLプログラム削除

　NULLをGLフレームバッファ設定
　FBリストを反復
　　対象["TEX"]をGLテクスチャ削除
　　対象["FB"]をGLフレームバッファ削除
　ここまで
　FBリストは空配列
ここまで

●(ルールを)ルール破棄とは
　もし、ルール["TEX"]≠NULLならば、
　　ルール["TEX"]をGLテクスチャ削除
　　ルール["TEX"]はNULL
　ここまで
　もし、(ルール["色"])かつ(ルール["色"]["TEX"]≠NULL)ならば、
　　ルール["色"]["TEX"]をGLテクスチャ削除
　　ルール["色"]["TEX"]はNULL
　ここまで
ここまで

●(バッファをデータで)バッファ更新とは
　バッファ["BUF"]をデータでGLバッファ配列更新
ここまで

●ワールド情報更新反映とは
　旧幅はワールド["TEX幅"]
　旧高はワールド["TEX高"]
　# データの保存に必要なテクスチャのサイズを求める
　基本底数は２でワールド["幅"]のLOGNを切り上げ
　ワールド["TEX幅"]は２の(基本底数)乗
　第二底数は２でワールド["高"]のLOGNを切り上げ
　ワールド["TEX高"]は２の(第二底数)乗

　もし、(ワールド["TEX幅"]≦旧幅)かつ(ワールド["TEX高"]≦旧高)ならば、
　　ワールド["TEX幅"]は旧幅
　　ワールド["TEX高"]は旧高
　ここまで

　# 上限反転無し
　Xはワールド["幅"]/ワールド["TEX幅"]*2-1
　Yはワールド["高"]/ワールド["TEX高"]*2-1
　Uはワールド["幅"]/ワールド["TEX幅"]
　Vはワールド["高"]/ワールド["TEX高"]
　# X,Y,U,Vの順
　更新頂点情報リストは[
    -1.0,    Y, 0.0,   V,
       X,    Y,   U,   V,
    -1.0, -1.0, 0.0, 0.0,
       X, -1.0,   U, 0.0
  ]
　更新頂点情報バッファを更新頂点情報リストでバッファ更新

　もし、(旧幅≠ワールド["TEX幅"])または(旧高≠ワールド["TEX高"])ならば、
　　0をGLテクスチャ枠指定
　　２回繰り返す
　　　FBリスト[回数-1]["FB"]をGLフレームバッファ削除
　　　FBリスト[回数-1]["TEX"]をGLテクスチャ削除
　　　TEXはNULLから[ワールド["TEX幅"],ワールド["TEX高"]]のGLテクスチャ作成
　　　FBリスト[回数-1]は{
　　　　FB: ({COLOR: TEX}のGLフレームバッファ作成),
　　　　TEX: TEX,
　　　　TEX幅: ワールド["TEX幅"],
　　　　TEX高: ワールド["TEX高"],
　　　　幅: ワールド["幅"],
　　　　高: ワールド["高"]
　　　}
　　ここまで
　違えば、
　　２回繰り返す
　　　FBリスト[回数-1]["幅"]はワールド["幅"]
　　　FBリスト[回数-1]["高"]はワールド["高"]
　　ここまで
　ここまで

　表示情報更新反映する
ここまで

●表示情報更新反映とは
　横分離はオフ
　縦分離はオフ
　もし、表示起点[0]＋画面幅÷表示倍率＞ワールド["幅"]ならば、
　　横分離はオン
　ここまで
　もし、表示起点[1]＋画面高÷表示倍率＞ワールド["高"]ならば、
　　縦分離はオン
　ここまで
　U1は表示起点[0]
　V1は表示起点[1]
　X1は0
　Y1は画面高
　もし、横分離ならば、
　　U2はワールド["幅"]
　　X2は(ワールド["幅"]－表示起点[0])×表示倍率

　　U3は0
　　U4は(表示起点[0]＋画面幅÷表示倍率－ワールド["幅"])
　　X3はX2
　　X4は画面幅
　違えば、
　　X2は画面幅
　　U2は(表示起点[0]＋画面幅÷表示倍率)
　ここまで
　もし、縦分離ならば、
　　V2はワールド["高"]
　　Y2は画面高－(ワールド["高"]－表示起点[1])×表示倍率

　　V3は0
　　V4は(表示起点[1]＋画面高÷表示倍率－ワールド["高"])
　　Y3はY2
　　Y4は0
　違えば、
　　Y2は0
　　V2は(表示起点[1]＋画面高÷表示倍率)
　ここまで
　頂点情報リストは[]

　# 左上相当
　頂点情報リストは頂点情報リストに[
      X1,   Y2,  U1,  V2,
      X2,   Y2,  U2,  V2,
      X1,   Y1,  U1,  V1,
      X1,   Y1,  U1,  V1,
      X2,   Y2,  U2,  V2,
      X2,   Y1,  U2,  V1
  ]を配列足す

　もし、横分離ならば、
　　# 右上相当
　　頂点情報リストは頂点情報リストに[
      X3,   Y2,  U3,  V2,
      X4,   Y2,  U4,  V2,
      X3,   Y1,  U3,  V1,
      X3,   Y1,  U3,  V1,
      X4,   Y2,  U4,  V2,
      X4,   Y1,  U4,  V1
    ]を配列足す
　ここまで
　もし、縦分離ならば、
　　# 左下相当
　　頂点情報リストは頂点情報リストに[
      X1,   Y4,  U1,  V4,
      X2,   Y4,  U2,  V4,
      X1,   Y3,  U1,  V3,
      X1,   Y3,  U1,  V3,
      X2,   Y4,  U2,  V4,
      X2,   Y3,  U2,  V3
    ]を配列足す
　ここまで
　もし、横分離＆＆縦分離ならば、
　　# 右下相当
　　頂点情報リストは頂点情報リストに[
      X3,   Y4,  U3,  V4,
      X4,   Y4,  U4,  V4,
      X3,   Y3,  U3,  V3,
      X3,   Y3,  U3,  V3,
      X4,   Y4,  U4,  V4,
      X4,   Y3,  U4,  V3
    ]を配列足す
　ここまで
　/* 「変換頂点情報:{頂点情報リストの配列要素数}」を表示
　(頂点情報リストの配列要素数)÷４回繰り返す
　　Iは回数-1
　　Xは頂点情報リスト[I*4+0]
　　Yは頂点情報リスト[I*4+1]
　　Uは頂点情報リスト[I*4+2]
　　Vは頂点情報リスト[I*4+3]
　　「{X},{Y},{U},{V}」を表示
　ここまで */
　# ピクセル単位からノーマライズする。あわせて、テクスチャ座標を上限反転する。
　スケールUは1/ワールド["TEX幅"]
　スケールVは1/ワールド["TEX高"]
　スケールXは1/画面幅
　スケールYは1/画面高
　(頂点情報リストの配列要素数)÷４回繰り返す
　　Iは回数-1
　　頂点情報リスト[I*4+0]は頂点情報リスト[I*4+0]×スケールX×２－１
　　頂点情報リスト[I*4+1]は頂点情報リスト[I*4+1]×スケールY×２－１
　　頂点情報リスト[I*4+2]は頂点情報リスト[I*4+2]×スケールU
　　頂点情報リスト[I*4+3]は頂点情報リスト[I*4+3]×スケールV
　ここまで
　表示頂点情報バッファを頂点情報リストでバッファ更新
　表示頂点情報バッファ["NUM"]は(頂点情報リストの配列要素数)÷４
ここまで

●(ルールを)ルール適用とは
　ルール["TYPE"]で条件分岐する
　　「GOL」ならば、
　　　ルールTEXはルール["DATA"]からCGOLルールTEX作成
　　ここまで
　　「CUSTOM」ならば、
　　　ルールTEXはルール["DATA"]からカスタムルールTEX作成
　　　もし、ルールTEX["ALIAS"]でなければ、
　　　　ルールTEX["ALIAS"]は空
　　　ここまで
　　ここまで
　　違えば、
　　　「ルールのTYPEが未知の値です({ルール["TYPE"]})」でエラー発生
　　ここまで
　ここまで
　色TEXはルール["COLORS"]で色TEX作成

　現ルールをルール破棄

　現ルール["TEX"]はルールTEX["TEX"]
　現ルール["TEX幅"]はルールTEX["幅"]
　現ルール["TEX高"]はルールTEX["高"]
　現ルール["種類数"]はルールTEX["種類数"]
　現ルール["隣接数"]はルールTEX["隣接数"]
　現ルール["色"]["TEX"]は色TEX["TEX"]
　現ルール["色"]["TEX幅"]は色TEX["幅"]
　現ルール["色"]["数"]は色TEX["数"]
　現ルール["名前"]はルール["NAME"]
　現ルール["別名"]はルールTEX["ALIAS"]
ここまで

●(データから)カスタムルールTEX作成とは
　もし、(データの変数型確認)≠"string"ならば、
　　チェック用データはデータを「」で配列結合
　違えば、
　　チェック用データはデータ
　ここまで
　もし、(チェック用データの「num_nodes=」が何文字目)＞０ならば、
　　データからツリールールTEX作成で戻る
　違えばもし、(チェック用データの「neighborhood:」が何文字目)＞０ならば、
　　データからテーブルルールTEX作成で戻る
　ここまで
　結果はチェック用データを『/^B([0-9]*)\/S([0-9]*)(\/([0-9]+))?$/』で正規表現マッチ
　もし、結果≠NULLならば、
　　データからCGOLルールTEX作成で戻る
　ここまで
　結果はチェック用データを『/^([0-9]*)\/([0-9]*)\/([0-9]+)$/』で正規表現マッチ
　もし、結果≠NULLならば、
　　データからCGOLルールTEX作成で戻る
　ここまで
　「不明なルールの定義方法です」でエラー発生
　空で戻る
ここまで

●(ルールの)ルール用配列準備とは
　データ数はルール["種類数"]のルール["隣接数"]乗
　テクセル数は(データ数/4)を切り上げ
　# データの保存に必要なテクスチャのサイズを求める
　基本底数は２で(テクセル数の平方根)のLOGNを切り上げ
　ルール幅は２の(基本底数)乗
　第二底数は２で(テクセル数÷ルール幅)のLOGNを切り上げ
　ルール高は２の(第二底数)乗
　# 「RULETEX=({ルール幅},{ルール高})」を表示
　ルール["幅"]はルール幅
　ルール["高"]はルール高
　(ルール幅*ルール高*4)のUI8配列で戻る
ここまで

●(ルールでデータを)ルール用データ初期化とは
　(ルール["幅"]*ルール["高"]*4)回繰り返す
　　データ[回数-1]は255
　ここまで
ここまで

●(ルールにデータで)ルール用TEX設定とは
　ルール["TEX"]はデータから[ルール["幅"],ルール["高"]]のGLテクスチャ作成
ここまで

「全て」を実行速度優先

●(ルールテキストから)CGOLルールTEX作成とは
　誕生は「3」
　生存は「23」
　世代は2
　結果はルールテキストを『/^B([0-9]*)\/S([0-9]*)(\/([0-9]+))?$/』で正規表現マッチ
　もし、結果≠NULLならば、
　　誕生は抽出文字列[0]
　　生存は抽出文字列[1]
　　もし、抽出文字列[3]≠NULLならば、
　　　世代は抽出文字列[3]-0
　　ここまで
　違えば
　　結果はルールテキストを『/^([0-9]*)\/([0-9]*)\/([0-9]+)$/』で正規表現マッチ
　　もし、結果≠NULLならば、
　　　生存は抽出文字列[0]
　　　誕生は抽出文字列[1]
　　　世代は抽出文字列[2]-0
　　違えば、
　　　空で戻る
　　ここまで
　ここまで

　隣接数は9
　種類数は世代

　ルールは{}
　ルール["種類数"]は種類数
　ルール["隣接数"]は隣接数
　ルール["ALIAS"]は「B{誕生}/S{生存}/G{世代}」

　データはルールのルール用配列準備

　# 中心を除く周囲の８個についてループのネストを構成する
　# 組み合わせにより、中心が変化するものには変化値を設定する。
　# 変化しないものについては、255を設定する。
　# 中心は最上位ビットとなるので、種類数^(9-1)となるのでそれを使用する。
　ONEは1
　TWOは2を種類数で割余

　死亡リストは空配列
　誕生リストは空配列
　(隣接数)回繰り返す
　　死亡リスト[回数-1]はTWO
　　誕生リスト[回数-1]は255
　ここまで
　(生存を文字列分解)を反復する
　　死亡リスト[対象]は255
　ここまで
　(誕生を文字列分解)を反復する
　　誕生リスト[対象]はONE
　ここまで

　Iは0
　現セル係数は種類数の(隣接数-1)乗
　(種類数)回繰り返す
　　Aは回数-1
　　ASは0+(A=1)
　　(種類数)回繰り返す
　　　Bは回数-1
　　　BSはAS+(B=1)
　　　(種類数)回繰り返す
　　　　Cは回数-1
　　　　CSはBS+(C=1)
　　　　(種類数)回繰り返す
　　　　　Dは回数-1
　　　　　DSはCS+(D=1)
　　　　　(種類数)回繰り返す
　　　　　　Eは回数-1
　　　　　　ESはDS+(E=1)
　　　　　　(種類数)回繰り返す
　　　　　　　Fは回数-1
　　　　　　　FSはES+(F=1)
　　　　　　　(種類数)回繰り返す
　　　　　　　　Gは回数-1
　　　　　　　　GSはFS+(G=1)
　　　　　　　　(種類数)回繰り返す
　　　　　　　　　Hは回数-1
　　　　　　　　　HSはGS+(H=1)

　# 周囲８マスの生きている(=1)セル数を数える

　# 死滅セルに対して周囲の数が誕生リストでオンになっていたら誕生する(=1)
　データ[I]は誕生リスト[HS]

　# 生存セルに対して周囲の数が死亡リストでオンになっていたら死滅(+1世代。2 or 0になる)する
　データ[I+現セル係数]は死亡リスト[HS]

　# Generations対応。第２世代以降は周囲に関係なく死滅まで＋１世代となる。
　もし、種類数＞２ならば、
　　(種類数－２)回繰り返す
　　　データ[I+現セル係数*(回数+1)]は((回数+2)を種類数で割余)
　　ここまで
　ここまで
　IはI+1

　　　　　　　　ここまで
　　　　　　　ここまで
　　　　　　ここまで
　　　　　ここまで
　　　　ここまで
　　　ここまで
　　ここまで
　ここまで

　ルールにデータでルール用TEX設定
　ルールで戻る
ここまで

ここまで

●(ルールテーブルから)テーブルルールTEX作成とは
　もし、(ルールテーブルの変数型確認)＝"string"ならば、
　　全行はルールテーブルを改行で区切る
　違えば、
　　全行はルールテーブル
　ここまで
　加工は空
　種類数は0
　隣接数は0
　全行データは空配列
　ヘッダチェック済はオフ
　(全行)を反復する
　　行は対象のトリム
　　もし、行が空ならば、
　　　# 空行はスキップする
　　違えばもし、行が「#」で文字列始まるならば、
　　　# コメント行はスキップする
　　違えばもし、行が「n_states:」で文字列始まるならば、
　　　値は行で10から文字抜出
　　　値は値のトリム
　　　もし、値-0＝０ならば、
　　　　「n_statesの指定が０か数値ではありません:{値}」でエラー発生
　　　ここまで
　　　種類数は値-0
　　違えばもし、行が「neighborhood:」で文字列始まるならば、
　　　値は行で14から文字抜出
　　　値で条件分岐する
　　　　「vonNeumann」ならば、
　　　　　隣接数は5
　　　　ここまで
　　　　「Moore」ならば、
　　　　　隣接数は9
　　　　ここまで
　　　　違えば、
　　　　　「neighborhoodの指定が未知です:{値}」でエラー発生
　　　　ここまで
　　　ここまで
　　違えばもし、行が「symmetries:」で文字列始まるならば、
　　　値は行で12から文字抜出
　　　値は値のトリム
　　　値で条件分岐する
　　　　「rotate4」ならば、
　　　　　加工は値
　　　　ここまで
　　　　違えば、
　　　　　「symmetriesの指定が未知です:{値}」でエラー発生
　　　　ここまで
　　　ここまで
　　違えばもし、行が「var」で文字列始まるならば、
　　　「var構文は未対応です」でエラー発生
　　違えば、
　　　もし、ヘッダチェック済でなければ、
　　　　もし、隣接数が０ならば、
　　　　　「neighborhoodがデータが始まるまでに指定がありません」でエラー発生
　　　　ここまで
　　　　もし、種類数が０ならば、
　　　　　「n_statesがデータが始まるまでに指定がありません」でエラー発生
　　　　ここまで
　　　　ヘッダチェック済はオン
　　　ここまで
　　　もし、(行の「,」が何文字目)＞０ならば、
　　　　行は行を「,」で区切る
　　　違えば、
　　　　行は行を文字列分解する
　　　ここまで
　　　全行データに行を配列追加する
　　ここまで
　ここまで

　ルールは{}
　ルール["種類数"]は種類数
　ルール["隣接数"]は隣接数

　データはルールのルール用配列準備

　ルールでデータをルール用データ初期化

　環境は{
　　加工:加工,
　　種類数:種類数,
　　隣接数:隣接数
　}

　全行データを反復する
　　対象をデータに環境でルールデータ加工設定
　ここまで

　ルールにデータでルール用TEX設定
　ルールで戻る
ここまで

●(行データをデータに環境で)ルールデータ加工設定とは
　中心値は行データの0から1を配列取出
　設定値は行データから配列ポップ
　周囲データは行データ
　もし、環境["加工"]が空ならば、
　　中心値から周囲データと設定値を環境でデータにルールデータ設定
　違えばもし、環境["隣接数"]が5ならば、
　　もし、環境["加工"]が「rotate4」ならば、
　　　4回繰り返す
　　　　中心値から周囲データと設定値を環境でデータにルールデータ設定
　　　　値は周囲データから配列ポップ
　　　　周囲データの0に値を配列挿入
　　　ここまで
　　違えば、
　　　「対応していない加工方法です」でエラー発生
　　ここまで
　違えばもし、環境["隣接数"]ならば、
　　「隣接:9には対応していません」でエラー発生
　違えば、
　　「内部エラーです。隣接数が正しくありません」でエラー発生
　ここまで
ここまで

●(データに中心値から周囲データと設定値を環境で)ルールデータ設定とは
　#「D:{環境["種類数"]}/{設定値}/{中心値}/{周囲データ}」を表示
　キー値は中心値
　周囲データを反復する
　　キー値はキー値×環境["種類数"]＋(対象－０)
　ここまで
　データ[キー値]は(設定値－０)
ここまで

●(ルールツリーから)ツリールールTEX作成とは
　もし、(ルールツリーの変数型確認)＝"string"ならば、
　　全行はルールツリーを改行で区切る
　違えば、
　　全行はルールツリー
　ここまで
　種類数は0
　隣接数は0
　全行データは空配列
　ヘッダチェック済はオフ
　(全行)を反復する
　　行は対象のトリム
　　もし、行が空ならば、
　　　# 空行はスキップする
　　違えばもし、行が「#」で文字列始まるならば、
　　　# コメント行はスキップする
　　違えばもし、行が「num_states=」で文字列始まるならば、
　　　値は行で12から文字抜出
　　　値は値のトリム
　　　もし、値-0＝０ならば、
　　　　「num_statesの指定が０か数値ではありません:{値}」でエラー発生
　　　ここまで
　　　種類数は値-0
　　違えばもし、行が「num_neighbors=」で文字列始まるならば、
　　　値は行で15から文字抜出
　　　値で条件分岐する
　　　　「4」ならば、
　　　　　隣接数は5
　　　　ここまで
　　　　「8」ならば、
　　　　　隣接数は9
　　　　ここまで
　　　　違えば、
　　　　　「num_neighborsの指定は4か8のみ利用可能です:{値}」でエラー発生
　　　　ここまで
　　　ここまで
　　違えばもし、行が「num_nodes=」で文字列始まるならば、
　　　# 利用しない
　　違えば、
　　　もし、ヘッダチェック済でなければ、
　　　　もし、隣接数が０ならば、
　　　　　「num_neighborsがデータが始まるまでに指定がありません」でエラー発生
　　　　ここまで
　　　　もし、種類数が０ならば、
　　　　　「num_statesがデータが始まるまでに指定がありません」でエラー発生
　　　　ここまで
　　　　ヘッダチェック済はオン
　　　ここまで
　　　もし、(行の「 」が何文字目)＞０ならば、
　　　　行は行を「 」で区切る
　　　違えば、
　　　　行は行を文字列分解する
　　　ここまで
　　　全行データに行を配列追加する
　　ここまで
　ここまで

　ルールは{}
　ルール["種類数"]は種類数
　ルール["隣接数"]は隣接数

　データはルールのルール用配列準備

　ルールでデータをルール用データ初期化

　環境は{
　　種類数:種類数,
　　隣接数:隣接数
　}

　処理済みはオフ
　全行データを反復する
　　もし、対象[0]＝隣接数ならば、
　　　全行データから対象をデータに環境で[]のツリーノード処理
　　　処理済みはオン
　　　抜ける
　　ここまで
　ここまで
　もし、処理済みでなければ、
　　「ツリー形式のルールの定義で起点となるノードがありません」でエラー発生
　ここまで

　# ルールのデータをルールダンプ

　ルールにデータでルール用TEX設定
　ルールで戻る
ここまで

●(ノードリストからノードをデータに環境で経路の)ツリーノード処理とは
　階層は(ノード[0]－０)
　もし、階層＝１ならば、
　　キー値は0
　　種類数は環境["種類数"]
　　最終値倍率は種類数の(環境["隣接数"]-1)乗
　　もし、環境["隣接数"]＝５ならば、
　　　キー値は経路[0]
　　　キー値はキー値×種類数＋経路[2]
　　　キー値はキー値×種類数＋経路[3]
　　　キー値はキー値×種類数＋経路[1]
　　違えば、
　　　キー値は経路[4]
　　　キー値はキー値×種類数＋経路[1]
　　　キー値はキー値×種類数＋経路[6]
　　　キー値はキー値×種類数＋経路[3]
　　　キー値はキー値×種類数＋経路[5]
　　　キー値はキー値×種類数＋経路[2]
　　　キー値はキー値×種類数＋経路[7]
　　　キー値はキー値×種類数＋経路[0]
　　ここまで
　　((ノードの配列要素数)-1)回繰り返す
　　　Nは回数－１
　　　Vは(ノード[回数]－０)
　　　データ[キー値＋N×最終値倍率]はV
　　ここまで
　違えば、
　　((ノードの配列要素数)-1)回繰り返す
　　　Nは回数－１
　　　Vは(ノード[回数]－０)
　　　新経路は(経路を配列複製)にNを配列追加
　　　ノードリストからノードリスト[V]をデータに環境で新経路のツリーノード処理
　　ここまで
　ここまで
ここまで

# 表示の際の色を指定するテクスチャを生成する
# セルの状態がXとして参照される。高さは１固定。

●(COLORSで)色TEX作成とは
　色数はCOLORSの配列要素数
　# データの保存に必要なテクスチャのサイズを求める
　基本底数は２で色数のLOGNを切り上げ
　色幅は２の(基本底数)乗
　色高は１
　# 「COLORTEX=({色幅},{色高})」を表示

　データは(色幅*色高*4)のUI8配列
　Iは0
　(色幅)回繰り返す
　　Iは回数-1
　　もし、I＜色数ならば、
　　　COLORはCOLORS[I]
　　　データ[I*4+0]はCOLOR[0]
　　　データ[I*4+1]はCOLOR[1]
　　　データ[I*4+2]はCOLOR[2]
　　　データ[I*4+3]は255
　　違えば、
　　　データ[I*4+0]は0
　　　データ[I*4+1]は0
　　　データ[I*4+2]は0
　　　データ[I*4+3]は0
　　ここまで
　ここまで

　TEXはデータから[色幅,色高]のGLテクスチャ作成

　色は{}
　色["TEX"]はTEX
　色["幅"]は色幅
　色["高"]は色高
　色["数"]は色数
　色で戻る
ここまで

# パーツ配置系

●(TEXTを)配置パーツ作成とは
　TEXTからカスタム配置パーツ作成で戻る
ここまで

●(FBの位置にパーツをOPTSで)配置中パーツ描画とは
　もし、パーツ＝NULLならば、
　　戻る
　ここまで
　パーツをFBの位置にOPTSでパーツ描画する
ここまで

●(FBにパーツを)パーツ全体描画とは
　FBに空初期化する
　配置幅はパーツ["幅"]
　配置高はパーツ["高"]
　回転は0
　もし、((パーツ["幅"]＞ワールド["幅"])または(パーツ["高"]＞ワールド["高"]))かつ((パーツ["幅"]≦ワールド["高"])かつ(パーツ["高"]≦ワールド["幅"]))ならば、
　　配置幅はパーツ["高"]
　　配置高はパーツ["幅"]
　　回転は90
　ここまで

　位置は[
　　(ワールド["幅"]÷2－配置幅÷2)の整数部分,
　　(ワールド["高"]÷2－配置高÷2)の整数部分
　]
　パーツをFBの位置に{ 回転: 回転, 反転: オフ }でパーツ描画する

　# FBのFBダンプ
ここまで

●(FBに配置を)配置適用とは
　もし、(配置["RULE"]≠現ルール["名前"])かつ(配置["RULE"]≠現ルール["別名"])ならば、
　　「ルールが異なるため適用できません」でエラー発生
　ここまで
　配置["TYPE"]で条件分岐する
　　「SIMPLE」ならば、
　　　パーツは配置["DATA"]からSIMPLE配置パーツ作成
　　ここまで
　　「RLE」ならば、
　　　パーツは配置["DATA"]からRLE配置パーツ作成
　　ここまで
　　「CUSTOM」ならば、
　　　パーツは配置["DATA"]からカスタム配置パーツ作成
　　ここまで
　　違えば、
　　　「配置データのTYPEが未知の値です({配置["TYPE"]})」でエラー発生
　　ここまで
　ここまで
　FBにパーツをパーツ全体描画
　パーツを配置パーツ破棄
　初期配置名は配置["NAME"]
ここまで

●(データから)カスタム配置パーツ作成とは
　もし、(データの変数型確認)≠"string"ならば、
　　チェック用データはデータを「」で配列結合
　違えば、
　　チェック用データはデータ
　ここまで
　もし、(チェック用データの「rule =」が何文字目)＞０ならば、
　　データからRLE配置パーツ作成で戻る
　違えば、
　　データからSIMPLE配置パーツ作成で戻る
　ここまで
　# 「不明な配置の定義方法です」でエラー発生
　空で戻る
ここまで
　

●(テキストデータから)SIMPLE配置パーツ作成とは
　もし、(テキストデータの変数型確認)＝"string"ならば、
　　全データはテキストデータを改行で区切る
　違えば、
　　全データはテキストデータ
　ここまで
　幅は0
　高は0
　全行データは空配列
　全データを反復する
　　行は対象のトリム
　　もし、行が空ならば、
　　　# 読み飛ばす
　　違えばもし、行が"#"で文字列始まるならば、
　　　# 読み飛ばす
　　違えば、
　　　もし、幅≠０かつ(行の文字数)≠幅ならば、
　　　　「文字数の異なる行が含まれています({幅}≠{行の文字数})」でエラー発生
　　　ここまで
　　　幅は行の文字数
　　　全行データに(行の文字列分解)を配列追加
　　ここまで
　ここまで
　高は全行データの配列要素数
　もし、幅＝０または高＝０ならば、
　　「データがありません」でエラー発生
　ここまで
　もし、((幅＞ワールド["幅"])かつ(幅＞ワールド["高"]))または((高＞ワールド["幅"])かつ(高＞ワールド["高"]))ならば、
　　「ワールドより広いため配置できません」でエラー発生
　ここまで

　パーツは{
　　幅: 幅,
　　高: 高
　}
　データはパーツの配置用配列準備
　データをパーツでパーツ用データ初期化

　(高)回繰り返す
　　Yは回数-1
　　(幅)回繰り返す
　　　Xは回数-1
　　　Iは(Y*パーツ["TEX幅"]+X)*4
　　　色は全行データ[Y][X]
　　　データ[I+0]は色-0
　　　データ[I+1]は0
　　　データ[I+2]は0
　　　データ[I+3]は255
　　ここまで
　ここまで

　パーツにデータでパーツ用TEX設定

　パーツで戻る
ここまで

●(テキストデータから)RLE配置パーツ作成とは
　もし、(テキストデータの変数型確認)＝"string"ならば、
　　全データはテキストデータを改行で区切る
　違えば、
　　全データはテキストデータ
　ここまで
　幅は0
　高は0
　対象ルールは空
　全行データは空配列
　全データを反復する
　　行は対象のトリム
　　もし、(行の文字数)＝０ならば、
　　　# 読み飛ばす
　　違えばもし、行が"#"で文字列始まるならば、
　　　# 読み飛ばす
　　違えばもし、(行の「, rule =」が何文字目)＞０ならば、
　　　要素列は行を「,」で区切る
　　　要素列を反復する
　　　　値列は対象を「 」で区切る
　　　　もし、(対象の「x =」が何文字目)＞０ならば、
　　　　　幅は(値列の配列ポップ)－０
　　　　違えばもし、(対象の「y =」が何文字目)＞０ならば、
　　　　　高は(値列の配列ポップ)－０
　　　　違えばもし、(対象の「rule =」が何文字目)＞０ならば、
　　　　　対象ルールは値列の配列ポップ
　　　　違えば、
　　　　　# 残りは無視する
　　　　ここまで
　　　ここまで
　　違えば、
　　　全行データに行を配列追加
　　ここまで
　ここまで
　もし、幅＝０または高＝０ならば、
　　「データがありません」でエラー発生
　ここまで
　
　結果は対象ルールを『/^B([0-9]*)\/S([0-9]*)(\/([0-9]+))?$/』で正規表現マッチ
　もし、結果≠NULLならば、
　　世代は2
　　誕生は抽出文字列[0]
　　生存は抽出文字列[1]
　　もし、抽出文字列[3]≠NULLならば、
　　　世代は抽出文字列[3]
　　ここまで
　　対象ルールは「B{誕生}/S{生存}/G{世代}」
　違えば
　　結果は対象ルールを『/^([0-9]*)\/([0-9]*)\/([0-9]+)$/』で正規表現マッチ
　　もし、結果≠NULLならば、
　　　生存は抽出文字列[0]
　　　誕生は抽出文字列[1]
　　　世代は抽出文字列[2]
　　　対象ルールは「B{誕生}/S{生存}/G{世代}」
　　ここまで
　ここまで

　もし、(現ルール["名前"]＝「ユーザ入力」)かつ(現ルール["別名"]＝空)ならば、
　　もし、(「{対象ルール}用のデータです。配置して問題ありませんか？」で二択)でなければ、
　　　「ユーザによる配置取り消し」でエラー発生
　　ここまで
　違えばもし、(対象ルール＝現ルール["名前"])または(対象ルール＝現ルール["別名"])ならば、
　　# 一致しているのでOK
　違えば、
　　もし、(「ルール名が異なります。そのまま配置しますか？」で二択)でなければ、
　　　「ルール名が一致しません」でエラー発生
　　ここまで
　ここまで
　もし、((幅＞ワールド["幅"])かつ(幅＞ワールド["高"]))または((高＞ワールド["幅"])かつ(高＞ワールド["高"]))ならば、
　　「ワールドより広いため配置できません」でエラー発生
　ここまで

　全セルは空配列
　係数は0
　Xは0
　Yは0
　全セル[Y]は空配列
　全行データを反復する
　　対象を文字列分解を反復する
　　　文字は対象
　　　もし、文字≧"0"かつ文字≦"9"ならば、
　　　　係数は係数×１０＋(文字－０)
　　　違えばもし、文字＝"!"ならば、
　　　　# データ終わり
　　　　抜ける
　　　違えばもし、文字＝"$"ならば、
　　　　もし、係数が0ならば、
　　　　　係数は1
　　　　ここまで
　　　　(係数)回繰り返す
　　　　　YはY+1
　　　　　Xは0
　　　　　全セル[Y]は空配列
　　　　ここまで
　　　　係数は0
　　　違えば、
　　　　もし、文字＝"b"ならば、
　　　　　値は0
　　　　違えばもし、文字＝"o"ならば、
　　　　　値は1
　　　　違えばもし、文字≧"A"かつ文字≦"Z"ならば、
　　　　　値は(文字のASC)－64
　　　　違えばもし、文字＝"."ならば、
　　　　　値は0
　　　　違えば、
　　　　　「不明な文字がありました」でエラー発生
　　　　ここまで
　　　　もし、係数が0ならば、
　　　　　係数は1
　　　　ここまで
　　　　(係数)回繰り返す
　　　　　全セル[Y][X]は値
　　　　　XはX+1
　　　　ここまで
　　　　係数は0
　　　ここまで
　　ここまで
　ここまで

　パーツは{
　　幅: 幅,
　　高: 高
　}

　データはパーツの配置用配列準備
　データをパーツでパーツ用データ初期化

　(高)回繰り返す
　　Yは回数-1
　　(幅)回繰り返す
　　　Xは回数-1
　　　Iは(Y*パーツ["TEX幅"]+X)*4
　　　色行は全セル[Y]
　　　もし、色行＝NULLならば、
　　　　色は0
　　　違えば、
　　　　色は色行[X]
　　　　もし、色＝NULLならば、
　　　　　色は0
　　　　ここまで
　　　ここまで
　　　データ[I+0]は色
　　　データ[I+1]は0
　　　データ[I+2]は0
　　　データ[I+3]は255
　　ここまで
　ここまで

　パーツにデータでパーツ用TEX設定

　パーツで戻る
ここまで

●(パーツの)配置用配列準備とは
　# データの保存に必要なテクスチャのサイズを求める
　基本底数は２でパーツ["幅"]のLOGNを切り上げ
　パーツ幅は２の(基本底数)乗
　第二底数は２でパーツ["高"]のLOGNを切り上げ
　パーツ高は２の(第二底数)乗
　# 「PARTSTEX=({パーツ幅},{パーツ高})」を表示
　パーツ["TEX幅"]はパーツ幅
　パーツ["TEX高"]はパーツ高
　(パーツ幅*パーツ高*4)のUI8配列で戻る
ここまで

●(パーツでデータを)パーツ用データ初期化とは
　(パーツ["TEX高"])回繰り返す
　　Yは回数-1
　　(パーツ["TEX幅"])回繰り返す
　　　Xは回数-1
　　　Iは(Y*パーツ["TEX幅"]+X)*4
　　　データ[I+0]は0
　　　データ[I+1]は0
　　　データ[I+2]は0
　　　もし、X≧パーツ["幅"]またはY≧パーツ["高"]ならば、
　　　　データ[I+3]は0
　　　違えば、
　　　　データ[I+3]は255
　　　ここまで
　　ここまで
　ここまで
ここまで

●(パーツにデータで)パーツ用TEX設定とは
　パーツ["TEX"]はデータから[パーツ["TEX幅"],パーツ["TEX高"]]のGLテクスチャ作成
ここまで

●(パーツを)配置パーツ破棄とは
　もし、パーツならば、
　　もし、パーツ["TEX"]&&パーツ["TEX"]≠NULLならば、
　　　パーツ["TEX"]をGLテクスチャ削除
　　　パーツ["TEX"]はNULL
　　ここまで
　ここまで
ここまで

# 全体配置

●(FBに)空初期化とは
　もし、空初期化用テクスチャでなければ、
　　空初期化用テクスチャは空配置TEX作成する
　ここまで
　FBに空初期化用テクスチャを全体初期描画する
　初期配置名は「ブランク」
ここまで

●(FBに)ランダム初期化とは
　TEXはランダム配置TEX作成する
　FBにTEXを全体初期描画する
　TEXをGLテクスチャ削除
　初期配置名は「ランダム」
ここまで

●空配置TEX作成とは
　データは(ワールド["TEX幅"]*ワールド["TEX高"]*4)のUI8配列
　(ワールド["TEX高"])回繰り返す
　　Yは回数-1
　　(ワールド["TEX幅"])回繰り返す
　　　Xは回数-1
　　　Iは(Y*ワールド["TEX幅"]+X)*4
　　　データ[I+0]は0
　　　データ[I+1]は0
　　　データ[I+2]は0
　　　もし、X≧ワールド["幅"]またはY≧ワールド["高"]ならば、
　　　　データ[I+3]は0
　　　違えば、
　　　　データ[I+3]は255
　　　ここまで
　　ここまで
　ここまで
　TEXはデータから[ワールド["TEX幅"],ワールド["TEX高"]]のGLテクスチャ作成
　TEXで戻る
ここまで

●ランダム配置TEX作成とは
　データは(ワールド["TEX幅"]*ワールド["TEX高"]*4)のUI8配列
　(ワールド["TEX高"])回繰り返す
　　Yは回数-1
　　(ワールド["TEX幅"])回繰り返す
　　　Xは回数-1
　　　Iは(Y*ワールド["TEX幅"]+X)*4
　　　もし、X≧ワールド["幅"]またはY≧ワールド["高"]ならば、
　　　　データ[I+0]は0
　　　　データ[I+1]は0
　　　　データ[I+2]は0
　　　　データ[I+3]は0
　　　違えば、
　　　　もし、(5の乱数)＜２ならば、
　　　　　色は((現ルール["種類数"]-1)の乱数)+1
　　　　　データ[I+0]は色
　　　　　データ[I+1]は0
　　　　　データ[I+2]は0
　　　　違えば
　　　　　データ[I+0]は0
　　　　　データ[I+1]は0
　　　　　データ[I+2]は0
　　　　ここまで
　　　　データ[I+3]は255
　　　ここまで
　　ここまで
　ここまで
　TEXはデータから[ワールド["TEX幅"],ワールド["TEX高"]]のGLテクスチャ作成
　TEXで戻る
ここまで

●(FBにTEXを)全体初期描画とは
　現PGMは初期化プログラム

　現PGM["PROGRAM"]をGLプログラム使用

　FB["FB"]をGLフレームバッファ設定

　パラメータ情報は{
　　属性: [全体頂点情報バッファ],
　　共有データ: {},
　　テクスチャ: {
　　　テクスチャ: TEX
　　}
　}
　使用リソースはパラメータ情報で現PGMにシェーダプログラムパラメータ設定

　[0,0,FB["TEX幅"],FB["TEX高"]]にGLビューポート設定
　[0.0, 0.0, 0.0, 0.0]にGLクリア色設定
　{COLOR:オン}でGLクリア

　全体頂点情報バッファ["TYPE"]で全体頂点情報バッファ["NUM"]をGL配列描画

　GLフラッシュする

　使用リソースをシェーダプログラムパラメータ解放
ここまで

●(FBの位置にパーツをOPTSで)パーツ描画とは
　描画幅はパーツ["幅"]
　描画高はパーツ["高"]
　回転はOPTS["回転"]
　反転はOPTS["反転"]
　もし、回転=NULLならば、
　　回転は0
　ここまで
　回転は回転を３６０で割った余り
　もし、反転=NULLならば、
　　反転はオフ
　ここまで
　もし、回転＝９０または回転＝２７０ならば、
　　描画幅はパーツ["高"]
　　描画高はパーツ["幅"]
　ここまで
　X1は位置[0]
　Y1は位置[1]
　X2は位置[0]＋描画幅
　Y2は位置[1]＋描画高
　U1は０
　V1は０
　U2はパーツ["幅"]
　V2はパーツ["高"]
　頂点情報リストは[]
　# 左上相当。回転０の反転無しとして設定（ただし、X2,Y2は回転修正済み）
　頂点情報リストは頂点情報リストに[
      X1,   Y2,  U1,  V2,
      X2,   Y2,  U2,  V2,
      X1,   Y1,  U1,  V1,
      X1,   Y1,  U1,  V1,
      X2,   Y2,  U2,  V2,
      X2,   Y1,  U2,  V1
  ]を配列足す
　もし、反転ならば、
　　頂点情報リスト[6]は頂点情報リスト[2]
　　頂点情報リスト[7]は頂点情報リスト[3]
　　頂点情報リスト[2]は頂点情報リスト[18]
　　頂点情報リスト[3]は頂点情報リスト[19]
　　頂点情報リスト[18]は頂点情報リスト[6]
　　頂点情報リスト[19]は頂点情報リスト[7]
　　頂点情報リスト[10]は頂点情報リスト[22]
　　頂点情報リスト[11]は頂点情報リスト[23]
　　頂点情報リスト[22]は頂点情報リスト[14]
　　頂点情報リスト[23]は頂点情報リスト[15]
　　頂点情報リスト[14]は頂点情報リスト[10]
　　頂点情報リスト[15]は頂点情報リスト[11]
　ここまで
　(回転＞０)の間繰り返す
　　OXは頂点情報リスト[2]
　　OYは頂点情報リスト[3]
　　頂点情報リスト[2]は頂点情報リスト[10]
　　頂点情報リスト[3]は頂点情報リスト[11]
　　頂点情報リスト[10]は頂点情報リスト[22]
　　頂点情報リスト[11]は頂点情報リスト[23]
　　頂点情報リスト[14]は頂点情報リスト[10]
　　頂点情報リスト[15]は頂点情報リスト[11]
　　頂点情報リスト[22]は頂点情報リスト[6]
　　頂点情報リスト[23]は頂点情報リスト[7]
　　頂点情報リスト[6]はOX
　　頂点情報リスト[7]はOY
　　頂点情報リスト[18]は頂点情報リスト[6]
　　頂点情報リスト[19]は頂点情報リスト[7]
　　回転は回転－９０
　ここまで
　/* 「変換頂点情報:{頂点情報リストの配列要素数}」を表示
　「パーツTEX:{パーツ["TEX幅"]},{パーツ["TEX高"]}」を表示
　「パーツ:{パーツ["幅"]},{パーツ["高"]}」を表示
　(頂点情報リストの配列要素数)÷４回繰り返す
　　Iは(回数-1)*4
　　Xは頂点情報リスト[I+0]
　　Yは頂点情報リスト[I+1]
　　Uは頂点情報リスト[I+2]
　　Vは頂点情報リスト[I+3]
　　「{X},{Y},{U},{V}」を表示
　ここまで */
　スケールXは1/ワールド["TEX幅"]
　スケールYは1/ワールド["TEX高"]
　スケールUは1/パーツ["TEX幅"]
　スケールVは1/パーツ["TEX高"]
　(頂点情報リストの配列要素数)÷４回繰り返す
　　Iは(回数-1)*4
　　頂点情報リスト[I+0]は頂点情報リスト[I+0]×スケールX×２－１
　　頂点情報リスト[I+1]は頂点情報リスト[I+1]×スケールY×２－１
　　頂点情報リスト[I+2]は頂点情報リスト[I+2]×スケールU
　　頂点情報リスト[I+3]は頂点情報リスト[I+3]×スケールV
　ここまで
　部分頂点情報バッファを頂点情報リストでバッファ更新
　部分頂点情報バッファ["NUM"]は(頂点情報リストの配列要素数)÷４

　現PGMは初期化プログラム

　現PGM["PROGRAM"]をGLプログラム使用

　FB["FB"]をGLフレームバッファ設定

　パラメータ情報は{
　　属性: [部分頂点情報バッファ],
　　共有データ: {},
　　テクスチャ: {
　　　テクスチャ: パーツ["TEX"]
　　}
　}
　使用リソースはパラメータ情報で現PGMにシェーダプログラムパラメータ設定
# パラメータ情報を表示
# 現PGMを表示

　[0,0,ワールド["TEX幅"],ワールド["TEX高"]]にGLビューポート設定

　"SCISSOR_TEST"のGL有効化
　[位置[0],位置[1],描画幅,描画高]にGLシザー設定

　[0.0, 0.0, 0.0, 0.0]にGLクリア色設定
　{COLOR:オン}でGLクリア

　部分頂点情報バッファ["TYPE"]で部分頂点情報バッファ["NUM"]をGL配列描画

　GLフラッシュする

　"SCISSOR_TEST"のGL無効化

　使用リソースをシェーダプログラムパラメータ解放
ここまで

●(位置にパーツをOPTSで)パーツ参考描画とは
　描画幅はパーツ["幅"]
　描画高はパーツ["高"]
　回転はOPTS["回転"]
　反転はOPTS["反転"]
　もし、回転=NULLならば、
　　回転は0
　ここまで
　回転は回転を３６０で割った余り
　もし、反転=NULLならば、
　　反転はオフ
　ここまで
　もし、回転＝９０または回転＝２７０ならば、
　　描画幅はパーツ["高"]
　　描画高はパーツ["幅"]
　ここまで
　# 表示座標を上下反転する
　X1は位置[0]×表示倍率
　Y1は位置[1]×表示倍率
　X2は(位置[0]＋描画幅)×表示倍率
　Y2は(位置[1]－描画高)×表示倍率
　U1は０
　V1は０
　U2はパーツ["幅"]
　V2はパーツ["高"]
　頂点情報リストは[]
　# 左上相当。回転０の反転無しとして設定（ただし、X2,Y2は回転修正済み）
　頂点情報リストは頂点情報リストに[
      X1,   Y2,  U1,  V2,
      X2,   Y2,  U2,  V2,
      X1,   Y1,  U1,  V1,
      X1,   Y1,  U1,  V1,
      X2,   Y2,  U2,  V2,
      X2,   Y1,  U2,  V1
  ]を配列足す
　もし、反転ならば、
　　頂点情報リスト[6]は頂点情報リスト[2]
　　頂点情報リスト[7]は頂点情報リスト[3]
　　頂点情報リスト[2]は頂点情報リスト[18]
　　頂点情報リスト[3]は頂点情報リスト[19]
　　頂点情報リスト[18]は頂点情報リスト[6]
　　頂点情報リスト[19]は頂点情報リスト[7]
　　頂点情報リスト[10]は頂点情報リスト[22]
　　頂点情報リスト[11]は頂点情報リスト[23]
　　頂点情報リスト[22]は頂点情報リスト[14]
　　頂点情報リスト[23]は頂点情報リスト[15]
　　頂点情報リスト[14]は頂点情報リスト[10]
　　頂点情報リスト[15]は頂点情報リスト[11]
　ここまで
　(回転＞０)の間繰り返す
　　OXは頂点情報リスト[2]
　　OYは頂点情報リスト[3]
　　頂点情報リスト[2]は頂点情報リスト[10]
　　頂点情報リスト[3]は頂点情報リスト[11]
　　頂点情報リスト[10]は頂点情報リスト[22]
　　頂点情報リスト[11]は頂点情報リスト[23]
　　頂点情報リスト[14]は頂点情報リスト[10]
　　頂点情報リスト[15]は頂点情報リスト[11]
　　頂点情報リスト[22]は頂点情報リスト[6]
　　頂点情報リスト[23]は頂点情報リスト[7]
　　頂点情報リスト[6]はOX
　　頂点情報リスト[7]はOY
　　頂点情報リスト[18]は頂点情報リスト[6]
　　頂点情報リスト[19]は頂点情報リスト[7]
　　回転は回転－９０
　ここまで
　/* 「変換頂点情報:{頂点情報リストの配列要素数}」を表示
　「パーツTEX:{パーツ["TEX幅"]},{パーツ["TEX高"]}」を表示
　「パーツ:{パーツ["幅"]},{パーツ["高"]}」を表示
　(頂点情報リストの配列要素数)÷４回繰り返す
　　Iは回数-1
　　Xは頂点情報リスト[I*4+0]
　　Yは頂点情報リスト[I*4+1]
　　Uは頂点情報リスト[I*4+2]
　　Vは頂点情報リスト[I*4+3]
　　「{X},{Y},{U},{V}」を表示
　ここまで */
　# ピクセル単位からノーマライズする。
　スケールXは1/画面幅
　スケールYは1/画面高
　スケールUは1/パーツ["TEX幅"]
　スケールVは1/パーツ["TEX高"]
　(頂点情報リストの配列要素数)÷４回繰り返す
　　Iは回数-1
　　頂点情報リスト[I*4+0]は頂点情報リスト[I*4+0]×スケールX×２－１
　　頂点情報リスト[I*4+1]は頂点情報リスト[I*4+1]×スケールY×２－１
　　頂点情報リスト[I*4+2]は頂点情報リスト[I*4+2]×スケールU
　　頂点情報リスト[I*4+3]は頂点情報リスト[I*4+3]×スケールV
　ここまで
　部分頂点情報バッファを頂点情報リストでバッファ更新
　部分頂点情報バッファ["NUM"]は(頂点情報リストの配列要素数)÷４

　現PGMは表示プログラム

　現PGM["PROGRAM"]をGLプログラム使用

　NULLをGLフレームバッファ設定

　パラメータ情報は{
　　属性: [部分頂点情報バッファ],
　　共有データ: {
　　　色テクスチャ幅: 現ルール["色"]["TEX幅"],
　　　アルファ値: 0.5,
　　　種類数: 現ルール["種類数"]
　　},
　　テクスチャ: {
　　　テクスチャ: パーツ["TEX"],
　　　色テクスチャ: 現ルール["色"]["TEX"]
　　}
　}
　使用リソースはパラメータ情報で現PGMにシェーダプログラムパラメータ設定

　[0,0,画面幅,画面高]にGLビューポート設定

　部分頂点情報バッファ["TYPE"]で部分頂点情報バッファ["NUM"]をGL配列描画

　GLフラッシュする

　使用リソースをシェーダプログラムパラメータ解放
ここまで

●(FBを)FB描画とは
　現PGMは表示プログラム

　現PGM["PROGRAM"]をGLプログラム使用

　NULLをGLフレームバッファ設定

　パラメータ情報は{
　　属性: [表示頂点情報バッファ],
　　共有データ: {
　　　色テクスチャ幅: 現ルール["色"]["TEX幅"],
　　　アルファ値: 1.0,
　　　種類数: 現ルール["種類数"]
　　},
　　テクスチャ: {
　　　テクスチャ: FB["TEX"],
　　　色テクスチャ: 現ルール["色"]["TEX"]
　　}
　}
　使用リソースはパラメータ情報で現PGMにシェーダプログラムパラメータ設定

　[0,0,画面幅,画面高]にGLビューポート設定
　[0.0, 0.0, 0.0, 1.0]にGLクリア色設定
　{COLOR:オン}でGLクリア

　表示頂点情報バッファ["TYPE"]で表示頂点情報バッファ["NUM"]をGL配列描画

　GLフラッシュする

　使用リソースをシェーダプログラムパラメータ解放
ここまで

●(FBSからFBDへ)FB更新とは

　現PGMは更新プログラム

　現PGM["PROGRAM"]をGLプログラム使用

　FBD["FB"]をGLフレームバッファ設定

　パラメータ情報は{
　　属性: [更新頂点情報バッファ],
　　共有データ: {
　　　テクスチャサイズ: [ワールド["TEX幅"], ワールド["TEX高"]],
　　　ルールテクスチャサイズ: [現ルール["TEX幅"], 現ルール["TEX高"]],
　　　ワールドサイズ: [ワールド["幅"], ワールド["高"]],
　　　種類数: 現ルール["種類数"],
　　　隣接数: 現ルール["隣接数"],
　　　ループ: ワールド["境界ループ"]＝「LOOP」
　　},
　　テクスチャ: {
　　　テクスチャ: FBS["TEX"],
　　　ルールテクスチャ: 現ルール["TEX"]
　　}
　}
　使用リソースはパラメータ情報で現PGMにシェーダプログラムパラメータ設定

　[0,0,ワールド["TEX幅"],ワールド["TEX高"]]にGLビューポート設定
　[0.0, 0.0, 0.0, 0.0]にGLクリア色設定
　{COLOR:オン}でGLクリア

　更新頂点情報バッファ["TYPE"]で更新頂点情報バッファ["NUM"]をGL配列描画

　GLフラッシュする

　使用リソースをシェーダプログラムパラメータ解放
ここまで

●(FBLのFBIからN)回FB更新とは

　現PGMは更新プログラム

　現PGM["PROGRAM"]をGLプログラム使用

　パラメータ情報は{
　　属性: [更新頂点情報バッファ],
　　共有データ: {
　　　テクスチャサイズ: [ワールド["TEX幅"], ワールド["TEX高"]],
　　　ルールテクスチャサイズ: [現ルール["TEX幅"], 現ルール["TEX高"]],
　　　ワールドサイズ: [ワールド["幅"], ワールド["高"]],
　　　種類数: 現ルール["種類数"],
　　　隣接数: 現ルール["隣接数"],
　　　ループ: ワールド["境界ループ"]＝「LOOP」
　　},
　　テクスチャ: {}
　}
　使用リソースはパラメータ情報で現PGMにシェーダプログラムパラメータ設定

　項目は現PGM["PARAM"]["ルールテクスチャ"]
　0をGLテクスチャ枠指定
　現ルール["TEX"]をGLテクスチャ設定
　0を項目["LOC"]に項目["TYPE"]でGL共有データ設定

　項目は現PGM["PARAM"]["テクスチャ"]
　1をGLテクスチャ枠指定
　1を項目["LOC"]に項目["TYPE"]でGL共有データ設定

　(N)回繰り返す
　　FBL[1-FBI]["FB"]をGLフレームバッファ設定

　　FBL[FBI]["TEX"]をGLテクスチャ設定

　　[0,0,ワールド["TEX幅"],ワールド["TEX高"]]にGLビューポート設定
　　[0.0, 0.0, 0.0, 0.0]にGLクリア色設定
　　{COLOR:オン}でGLクリア

　　更新頂点情報バッファ["TYPE"]で更新頂点情報バッファ["NUM"]をGL配列描画

　　GLフラッシュする

　　FBIは1-FBI
　ここまで

　0をGLテクスチャ枠指定
　NULLをGLテクスチャ設定
　1をGLテクスチャ枠指定
　NULLをGLテクスチャ設定

　使用リソースをシェーダプログラムパラメータ解放

　FBIで戻る
ここまで

# TEST

●(ルールのピクセルデータを)ルールダンプとは
　# FBは{COLOR: ルール["TEX"]}のGLフレームバッファ作成
　# ピクセルデータはFBの[0,0]から[ルール["TEX幅"],ルール["TEX高"]]をデータ読取

　ステータス配列は空配列
　(ルール["隣接数"])回繰り返す
　　ステータス配列[回数-1]は0
　ここまで
　ダミー配列は空配列
　ルール数はルール["種類数"]のルール["隣接数"]乗
　(ルール数)回繰り返す
　　Iは回数-1
　　キーは「」
　　(ルール["隣接数"])回繰り返す
　　　キーは「{キー} {ステータス配列[回数-1]}」
　　ここまで
　　ダミー配列[I]は「{キー} = {ピクセルデータ[I]}」
　　(ルール["隣接数"])回繰り返す
　　　ステータス配列[回数-1]はステータス配列[回数-1]+1
　　　もし、ステータス配列[回数-1]＝ルール["種類数"]ならば、
　　　　ステータス配列[回数-1]は0
　　　違えば、
　　　　抜ける
　　　ここまで
　　ここまで
　ここまで
　ダミー配列を表示
ここまで

●(FBの)FBダンプとは
　ピクセルデータはFB["FB"]の[0,0]から[ワールド["TEX幅"],ワールド["TEX高"]]をデータ読取
　ダミー配列は空配列
　エラー配列は空配列
　(ワールド["TEX高"])回繰り返す
　　Yは回数-1
　　ダミー配列[Y]は空配列
　　(ワールド["TEX幅"])回繰り返す
　　　Xは回数-1
　　　Iは(Y*ワールド["TEX幅"]+X)*4
　　　エラー有はオフ
　　　もし、ピクセルデータ[I+0]≧現ルール["種類数"]ならば、
　　　　エラー配列に「CELL({X},{Y}):R異常({ピクセルデータ[I+0]})」を配列追加
　　　　エラー有はオン
　　　ここまで
　　　もし、ピクセルデータ[I+1]≠０ならば、
　　　　エラー配列に「CELL({X},{Y}):G異常({ピクセルデータ[I+1]})」を配列追加
　　　　エラー有はオン
　　　ここまで
　　　もし、ピクセルデータ[I+2]≠０ならば、
　　　　エラー配列に「CELL({X},{Y}):B異常({ピクセルデータ[I+2]})」を配列追加
　　　　エラー有はオン
　　　ここまで
　　　もし、ピクセルデータ[I+3]≠０かつピクセルデータ[I+3]≠２５５ならば、
　　　　エラー配列に「CELL({X},{Y}):A異常({ピクセルデータ[I+3]})」を配列追加
　　　　エラー有はオン
　　　ここまで
　　　もし、エラー有ならば、
　　　　ダミー配列[Y][X]は「X{ピクセルデータ[I+0]}」
　　　違えば、
　　　　もし、ピクセルデータ[I+3]＝０ならば、
　　　　　ダミー配列[Y][X]は「-{ピクセルデータ[I+0]}」
　　　　違えば、
　　　　　ダミー配列[Y][X]は「O{ピクセルデータ[I+0]}」
　　　　ここまで
　　　ここまで
　　ここまで
　ここまで
　ダミー配列を表示
　エラー配列を表示
ここまで

●(FBのXYからWHを)データ読取とは
　データは(WH[0]*WH[1]*4)のUI8配列
　FBをGLフレームバッファ設定
　GLの"readPixels"を[XY[0], XY[1], WH[0], WH[1], GL["RGBA"], GL["UNSIGNED_BYTE"], データ]でJSメソッド実行
　NULLをGLフレームバッファ設定
　データで戻る
ここまで

# 補助関数

●(CALLBACKを)変数内とは
　CALLBACKで戻る
ここまで

# 文字列操作関数群

●(STRがSで)文字列始まるとは
　もし、(STRの文字数)＜(Sの文字数)ならば、オフで戻る
　LはSの文字数
　もし、(STRの(L)文字左部分)＝Sならば、オンで戻る
　オフで戻る
ここまで

# 数学関数群

●(AのN)乗とは
　『(function (a,b) {return Math.pow(a,b)})』を[A,N]でJS関数実行で戻る
ここまで

ここまで