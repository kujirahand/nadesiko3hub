### [作品情報]
### 掲載URL=https://n3s.nadesi.com/id.php?3059
### タイトル=nadesiko3-music.js
### 作者=クジラ飛行机(user_id=1)
### ライセンス=MIT
### 説明=nadesiko3-music.js
### 対象バージョン=3.7.8
### URL=
### 種類=wnako
### タグ=w_noname
### 更新日時=2025-09-15 00:32:35
###

// nadesiko3-music.js
const SAKURAMML_VER = '0.1.44' // sakurammlのバージョン
const SARKUAMML_URL = `https://cdn.jsdelivr.net/npm/sakuramml@${SAKURAMML_VER}/sakuramml.js`
const PICOAUDIO_VER = '1.1.2' // picoaudioのバージョン
const PICOAUDIO_URL = `https://cdn.jsdelivr.net/npm/picoaudio@${PICOAUDIO_VER}/dist/browser/PicoAudio.min.js`
const LIBFLUIDSYNTH_VER = '2.4.6' // libfluidsynthのバージョン
const LIBFLUIDSYNTH_URL = `https://nadesi.com/v3/common/music/libfluidsynth-${LIBFLUIDSYNTH_VER}-with-libsndfile.js`
const JS_SYNTH_VER = '1.11.0' // js-synthesizerのバージョン
const JS_SYNTH_URL = `https://nadesi.com/v3/common/music/js-synthesizer@${JS_SYNTH_VER}.min.js`
const DEFAULT_SOUNDFONT_URL = 'https://sakuramml.com/picosakura/synth/fonts/TimGM6mb.sf2'

const PluginMusic = {
    'meta': {
        type: 'const',
        value: {
            pluginName: 'plugin_music', // プラグインの名前
            description: '音楽を再生するためのプラグイン', // 説明
            pluginVersion: '3.6.3', // プラグインのバージョン
            nakoRuntime: ['wnako'], // 対象ランタイム
            nakoVersion: '3.6.6' // 要求なでしこバージョン
        }
    },
    '初期化': {
        type: 'func',
        josi: [],
        fn: function (sys) {
            sys.__picoaudio = undefined
            sys.__sakuramml = undefined
            sys.__soundfont = undefined
        }
    },
    '!クリア': {
        type: 'func',
        josi: [],
        fn: function (sys) {
            // 演奏中であれば停める
            if (typeof (sys.__picoaudio) !== 'undefined') {
                sys.__picoaudio.initStatus()
            }
        }
    },
    // @音楽
    'MML演奏': { // @MMLを演奏する // @MMLえんそう
        type: 'func',
        josi: [['を', 'の']],
        fn: function (mml, sys) {
            if (typeof(sys.__sakuramml) === 'undefined') {
                // プレイヤーの読み込み
                loadScript(PICOAUDIO_URL, () => {
                    sys.__picoaudio = new PicoAudio()
                    console.log('loaded PicoAudio.min.js')
                });
                // コンパイラの読み込み
                import(SARKUAMML_URL)
                .then(module => {
                    sys.__sakuramml = module;
                    module.default().then(() => {
                        console.log('loaded sakuramml.js')
                        console.log('sakuramml ver.', module.get_version());
                        playMML(mml, sys)
                    })
                });
            } else {
                playMML(mml, sys)
            }
        },
        return_none: true
    },
    'MML停止': { // @MML演奏で開始した演奏を停止する // @MMLていし
        type: 'func',
        josi: [],
        fn: function (sys) {
            if (typeof (sys.__picoaudio) === 'undefined') {
                return
            }
            sys.__picoaudio.initStatus()
        }
    },
    'MIDI演奏': { // @MIDIファイルのあるURLを指定して演奏する // @MIDIえんそう
        type: 'func',
        josi: [['を', 'の']],
        asyncFn: true,
        fn: async function (url, sys) {
            // プレイヤーの読み込み
            if (typeof(sys.__picoaudio) === 'undefined') {
                loadScript(PICOAUDIO_URL, () => {
                    sys.__picoaudio = new PicoAudio()
                    console.log('loaded PicoAudio.min.js')
                    playMIDI(url, sys)
                });
            }
            playMIDI(url, sys)
        },
        return_none: true
    },
    'MIDI停止': { // @MIDI演奏で開始した演奏を停止する // @MIDIていし
        type: 'func',
        josi: [],
        fn: function (sys) {
            if (typeof (sys.__picoaudio) === 'undefined') {
                return
            }
            sys.__picoaudio.initStatus()
        }
    },
    'MIDIループ再生設定': { // @V(オン|オフ)にMML演奏/MIDI演奏で再生をループするように指定 // @MIDIるーぷさいせいせってい
        type: 'func',
        josi: [['に', 'へ']],
        fn: function (v, sys) {
            sys.__picoaudio_loop = v
        }
    },
    'MMLコンパイル': { // @MMLをコンパイルしてMIDIファイルに変換する // @MMLこんぱいる
        type: 'func',
        josi: [['を', 'の']],
        asyncFn: true,
        fn: function (mml, sys) {
            return new Promise((resolve, _reject) => {
                if (typeof(sys.__sakuramml) === 'undefined') {
                    // コンパイラの読み込み
                    import(SARKUAMML_URL)
                    .then(module => {
                        sys.__sakuramml = module;
                        module.default().then(() => {
                            console.log('loaded sakuramml.js')
                            console.log('sakuramml ver.', module.get_version());
                            resolve(compileMML(mml, sys))
                        })
                    });
                } else {
                    // すでに読み込まれている
                    resolve(compileMML(mml, sys))
                }
            })
        }
    },
    // @サウンドフォント
    'サウンドフォント読': { // @サウンドフォントのURLを指定して読み込む。URLに「デフォルト」を指定可能 // @サウンドフォントよむ
        type: 'func',
        josi: [['から', 'の']],
        asyncFn: true,
        fn: async function (url, sys) {
            // サウンドフォントのバイナリデータを読み込む
            if (url === 'デフォルト') {
                url = DEFAULT_SOUNDFONT_URL
            }
            console.log('load SoundFont file=', url)
            try {
                const response = await fetch(url)
                if (!response.ok) {
                    console.error('サウンドフォントの読み込みでURLのエラー : fetch error', response)
                    return
                }
                const buffer = await response.arrayBuffer()
                const sfData = new Uint8Array(buffer)
                sys.__soundfont = sfData
                console.log('loaded SoundFont file, size=', sfData.length)
            } catch (error) {
                console.error('サウンドフォントの読み込みでURLのエラー : ', error)
                sys.__soundfont = undefined
                throw error
            }
            return sfData
        }
    },
    'サウンドフォントMIDI演奏': { // @MIDIデータ(バイナリ)を指定して読み込む // @サウンドフォントえんそう
        type: 'func',
        josi: [['を', 'の']],
        asyncFn: true,
        fn: async function (bin, sys) {
            if (typeof(sys.__soundfont) === 'undefined') {
                throw new Error('サウンドフォントが読み込まれていません。先に「サウンドフォント読む」で読み込んでください。')
            }
            // SoundFontを使ってMIDIを演奏する
            await playMIDIWithSoundFont(bin , sys.__soundfont, sys)
        }
    },
    'サウンドフォントMIDI演奏停止': { // @再生中のMIDI演奏を停止する // @サウンドフォントえんそうていし
        type: 'func',
        josi: [],
        asyncFn: true,
        fn: async function (sys) {
            if (typeof (sys.__jssynth) === 'undefined') {
                return
            }
            await sys.__jssynth.stopPlayer()
            try {
                if (typeof(sys.__audio_context) !== 'undefined') {
                    await sys.__audio_context.close()
                    sys.__audio_context = undefined
                }
            } catch (e) {
                console.error('AudioContext close error:', e)
            }
        }
    }
}

/// SoundFontを使ってMIDIを演奏する
async function playMIDIWithSoundFont(binMidi, soundfont, sys) {
    if (typeof (FluidSynth) === 'undefined' || typeof (JSSynthesizer) === 'undefined') {
        throw new Error('FluidSynthかJSSynthesizerが読み込まれていません。')
    }
    // ライブラリの読み込み
    await loadScriptAsync(LIBFLUIDSYNTH_URL)
    await loadScriptAsync(JS_SYNTH_URL)
    // オーディオコンテキストの初期化
    var context = new AudioContext();
    var synth = new JSSynth.Synthesizer();
    synth.init(context.sampleRate);

    // Create AudioNode (ScriptProcessorNode) to output audio data
    var node = synth.createAudioNode(context, 8192); // 8192 is the frame count of buffer
    node.connect(context.destination);

    await synth.loadSFont(soundfont)
    await synth.addSMFDataToPlayer(binMidi)
    await synth.playPlayer()

    sys.__audio_context = context
    return sys.__jssynth = synth
}

/// MMLをコンパイルしてMIDIバイナリを返す
function compileMML(mml, sys) {
    const SakuraCompiler = sys.__sakuramml.SakuraCompiler
    const com = SakuraCompiler.new()
    com.set_language('ja')
    const binMidi = com.compile(mml)
    const log = com.get_log()
    console.log('sakuramml.log=', log)
    return binMidi
}

/// MMLを演奏する(PicoAudioを使う)
function playMML(mml, sys) {
    // wait for picoaudio
    if (typeof(sys.__picoaudio) === 'undefined') {
        setTimeout(() => { playMML(mml, sys) }, 100)
        return
    }
    // play
    const SakuraCompiler = sys.__sakuramml.SakuraCompiler
    const com = SakuraCompiler.new()
    com.set_language('ja')
    const binMidi = compileMML(mml, sys)
    const smfData = new Uint8Array(binMidi);
    sys.__picoaudio.initStatus()
    const parsedData = sys.__picoaudio.parseSMF(smfData)
    sys.__picoaudio.setData(parsedData)
    sys.__picoaudio.init()
    // ループ再生設定
    if (sys.__picoaudio_loop) {
        sys.__picoaudio.setLoop(true)
    } else {
        sys.__picoaudio.setLoop(false)
    }
    sys.__picoaudio.play()
}

function playMIDI(url, sys) {
    // wait for picoaudio
    if (typeof (sys.__picoaudio) === 'undefined') {
        setTimeout(() => { playMIDI(url, sys) }, 100)
        return
    }
    // fetch midi
    console.log('load MIDI file=')
    fetch(url)
    .then(response => {
        if (!response.ok) {
            console.error('MIDI演奏でURLのエラー : fetch error', response)
            return
        }
        return response.arrayBuffer()
    })
    .then(buffer => {
        const smfData = new Uint8Array(buffer)
        // console.log('smfData=', smfData)
        sys.__picoaudio.initStatus()
        const parsedData = sys.__picoaudio.parseSMF(smfData)
        sys.__picoaudio.setData(parsedData)
        sys.__picoaudio.init()
        // ループ再生設定
        if (sys.__picoaudio_loop) {
            sys.__picoaudio.setLoop(true)
        } else {
            sys.__picoaudio.setLoop(false)
        }
        sys.__picoaudio.play()
    })
    .catch(error => {
        console.error('MIDI演奏でURLのエラー : ', error)
    })
}

/// 非同期でスクリプトを読み込む
async function loadScriptAsync(url) {
    return new Promise((resolve, _reject) => {
        loadScript(url, () => {
            resolve()
        })
    })
}


function loadScript(url, callback) {
    // 新しいscript要素を作成
    var script = document.createElement('script');
    script.type = 'text/javascript';
    script.src = url;
    // スクリプトの読み込みが完了した際のコールバックを設定
    if (callback) {
        script.onload = callback;
    }

    // script要素をドキュメントに追加
    document.head.appendChild(script);
}

// scriptタグで取り込んだ時、自動で登録する
/* istanbul ignore else */
if (typeof (navigator) === 'object' && typeof (navigator.nako3) === 'object') {
    console.log('nadesiko3-music.js loaded.')
    navigator.nako3.addPluginObject('PluginMusic', PluginMusic)
}
// module.exports = PluginMusic
// export default PluginMusic